<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes, viewport-fit=cover">
    <meta name="theme-color" content="#080808">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Lip Sync Pro - 3D Anatomy</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@vladmandic/face-api/dist/face-api.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js" crossorigin="anonymous"></script>
    <style>
        :root {
            --accent: #ff00ff;
            --bg: #080808;
            --panel: #141414;
            --text: #ccc;
            --touch-target-min: 44px;
        }

        * {
            -webkit-tap-highlight-color: rgba(255, 0, 255, 0.3);
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--bg);
            color: var(--text);
            margin: 0;
            padding: 20px;
            height: 100vh;
            overflow: hidden;
            /* Prevent pull-to-refresh on mobile */
            overscroll-behavior: none;
            touch-action: pan-x pan-y;
        }

        .layout {
            display: grid;
            grid-template-columns: 1fr 380px;
            gap: 20px;
            height: 95vh;
            max-width: 1900px;
            margin: 0 auto;
        }

        .stage {
            background: #000;
            border-radius: 12px;
            border: 1px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
            min-height: 300px;
        }

        canvas {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            filter: drop-shadow(0 0 50px rgba(0,0,0,0.5));
            touch-action: none;
        }

        .controls {
            background: var(--panel);
            padding: 25px;
            border-radius: 12px;
            border: 1px solid #333;
            overflow-y: auto;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
            gap: 18px;
            /* Smooth scrolling on iOS */
            -webkit-overflow-scrolling: touch;
        }

        h1 {
            font-size: 1.4rem;
            color: #fff;
            margin: 0 0 5px 0;
            border-bottom: 2px solid var(--accent);
            display: inline-block;
            padding-bottom: 8px;
            letter-spacing: 1px;
        }

        h3 {
            font-size: 0.85rem;
            text-transform: uppercase;
            color: #666;
            margin: 5px 0 10px 0;
            font-weight: 700;
            letter-spacing: 0.5px;
        }

        .panel {
            background: #1f1f1f;
            padding: 16px;
            border-radius: 8px;
            border: 1px solid #2a2a2a;
        }

        .slider-row {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
            min-height: var(--touch-target-min);
        }

        .slider-row label {
            font-size: 0.8rem;
            width: 110px;
            color: #aaa;
            font-weight: 500;
        }

        input[type=range] {
            flex: 1;
            accent-color: var(--accent);
            height: 8px;
            background: #444;
            border-radius: 4px;
            cursor: pointer;
            /* Better touch targets for mobile */
            min-height: 44px;
            padding: 18px 0;
        }

        /* Make range slider thumb larger on touch devices */
        input[type=range]::-webkit-slider-thumb {
            width: 24px;
            height: 24px;
            background: var(--accent);
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid #fff;
        }

        input[type=range]::-moz-range-thumb {
            width: 24px;
            height: 24px;
            background: var(--accent);
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid #fff;
        }

        .btn-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn {
            flex: 1;
            padding: 14px 16px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: 0.2s;
            background: #2a2a2a;
            color: #fff;
            font-size: 0.85rem;
            text-transform: uppercase;
            min-width: 120px;
            min-height: var(--touch-target-min);
            /* Prevent text selection on mobile */
            user-select: none;
            -webkit-user-select: none;
            /* Better touch feedback */
            touch-action: manipulation;
        }

        .btn:hover {
            background: #333;
            color: var(--accent);
        }

        .btn:active {
            transform: scale(0.97);
            background: #3a3a3a;
        }

        .btn-primary {
            background: var(--accent);
            color: #fff;
        }

        .btn-primary:hover {
            background: #d600d6;
            color: #fff;
        }

        .btn-primary:active {
            background: #b000b0;
        }

        .btn-danger {
            background: #d32f2f;
            color: #fff;
        }

        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .tabs {
            display: flex;
            background: #222;
            padding: 4px;
            border-radius: 6px;
            margin-bottom: 15px;
            gap: 4px;
        }

        .tab {
            flex: 1;
            text-align: center;
            padding: 12px 8px;
            font-size: 0.85rem;
            cursor: pointer;
            color: #888;
            border-radius: 4px;
            transition: 0.2s;
            font-weight: 600;
            min-height: var(--touch-target-min);
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            touch-action: manipulation;
        }

        .tab.active {
            background: #333;
            color: #fff;
        }

        .tab:active {
            transform: scale(0.97);
        }

        .upload-zone {
            border: 2px dashed #444;
            padding: 40px;
            text-align: center;
            border-radius: 8px;
            cursor: pointer;
            transition: 0.2s;
            color: #666;
            min-height: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }

        .upload-zone:hover {
            border-color: var(--accent);
            color: #fff;
            background: #111;
        }

        .overlay-msg {
            position: absolute;
            background: rgba(0,0,0,0.9);
            padding: 20px;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 20;
            color: #fff;
            max-width: 90vw;
        }

        .spinner {
            width: 30px;
            height: 30px;
            border: 3px solid #333;
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hint {
            font-size: 0.75rem;
            color: #666;
            margin-top: 5px;
            text-align: center;
            font-style: italic;
        }

        .btn:focus {
            outline: 2px solid var(--accent);
            outline-offset: 2px;
        }

        /* Input elements touch optimization */
        input[type="text"],
        input[type="number"],
        input[type="file"],
        select,
        textarea {
            min-height: var(--touch-target-min);
            font-size: 16px; /* Prevents zoom on iOS */
            padding: 12px;
            border-radius: 6px;
            border: 1px solid #444;
            background: #2a2a2a;
            color: #fff;
        }

        /* Checkbox and radio button sizing */
        input[type="checkbox"],
        input[type="radio"] {
            min-width: 24px;
            min-height: 24px;
            cursor: pointer;
            accent-color: var(--accent);
        }

        /* ========================================
           RESPONSIVE BREAKPOINTS
           ======================================== */

        /* Large tablets and small desktops (1024px - 1199px) */
        @media (max-width: 1199px) {
            .layout {
                grid-template-columns: 1fr 320px;
                gap: 15px;
            }
            .controls {
                padding: 20px;
            }
            body {
                padding: 15px;
            }
        }

        /* Tablets portrait and landscape (768px - 1023px) */
        @media (max-width: 1023px) {
            .layout {
                grid-template-columns: 1fr;
                height: auto;
                max-height: 95vh;
            }

            .controls {
                order: 1;
                max-height: 45vh;
                gap: 12px;
            }

            .stage {
                order: 2;
                height: 45vh;
                min-height: 300px;
            }

            h1 {
                font-size: 1.2rem;
            }

            .slider-row label {
                width: 100px;
                font-size: 0.75rem;
            }
        }

        /* Mobile landscape and large phones (640px - 767px) */
        @media (max-width: 767px) {
            body {
                padding: 10px;
            }

            .layout {
                gap: 10px;
                height: auto;
            }

            .controls {
                padding: 15px;
                max-height: 50vh;
                gap: 10px;
            }

            .stage {
                height: 40vh;
                min-height: 250px;
                border-radius: 8px;
            }

            .panel {
                padding: 12px;
            }

            h1 {
                font-size: 1.1rem;
                padding-bottom: 6px;
            }

            h3 {
                font-size: 0.75rem;
                margin: 3px 0 8px 0;
            }

            .btn {
                font-size: 0.75rem;
                padding: 12px;
                min-width: 100px;
            }

            .tab {
                font-size: 0.7rem;
                padding: 10px 4px;
            }

            .slider-row {
                gap: 8px;
            }

            .slider-row label {
                width: 85px;
                font-size: 0.7rem;
            }

            .upload-zone {
                padding: 30px 15px;
                min-height: 100px;
            }

            .hint {
                font-size: 0.7rem;
            }
        }

        /* Mobile portrait (480px - 639px) */
        @media (max-width: 639px) {
            .controls {
                max-height: 55vh;
            }

            .stage {
                height: 35vh;
                min-height: 200px;
            }

            .btn-row {
                gap: 8px;
            }

            .btn {
                min-width: 90px;
                flex: 1 1 calc(50% - 4px); /* 2 columns on small screens */
            }

            /* Make some buttons full width for better usability */
            .btn-primary {
                flex: 1 1 100%;
                min-width: 100%;
            }
        }

        /* Small mobile devices (320px - 479px) */
        @media (max-width: 479px) {
            body {
                padding: 8px;
            }

            .layout {
                gap: 8px;
            }

            .controls {
                padding: 12px;
                max-height: 60vh;
                gap: 8px;
            }

            .stage {
                height: 30vh;
                min-height: 180px;
                border-radius: 6px;
            }

            .panel {
                padding: 10px;
                border-radius: 6px;
            }

            h1 {
                font-size: 1rem;
            }

            h3 {
                font-size: 0.7rem;
            }

            .btn {
                font-size: 0.7rem;
                padding: 12px 8px;
                min-width: 80px;
            }

            .tab {
                font-size: 0.65rem;
                padding: 10px 2px;
            }

            .slider-row {
                flex-direction: column;
                align-items: flex-start;
                gap: 4px;
            }

            .slider-row label {
                width: 100%;
                font-size: 0.7rem;
            }

            input[type=range] {
                width: 100%;
            }

            .upload-zone {
                padding: 20px 10px;
                min-height: 80px;
                font-size: 0.8rem;
            }
        }

        /* Orientation-specific styles */
        @media (max-width: 767px) and (orientation: landscape) {
            .layout {
                grid-template-columns: 1fr 280px;
                height: 90vh;
            }

            .controls {
                order: 2;
                max-height: 90vh;
            }

            .stage {
                order: 1;
                height: 90vh;
            }
        }

        @media (max-width: 639px) and (orientation: landscape) {
            body {
                padding: 5px;
            }

            .controls {
                padding: 10px;
                max-width: 260px;
            }

            h1 {
                font-size: 0.9rem;
            }

            h3 {
                font-size: 0.65rem;
                margin: 2px 0 6px 0;
            }

            .panel {
                padding: 8px;
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const App = () => {
            const [image, setImage] = React.useState(null);
            const [status, setStatus] = React.useState("Ready");
            const [modelsLoaded, setModelsLoaded] = React.useState(false);
            const [isDetecting, setIsDetecting] = React.useState(false);
            
            // Vector Mask for mouth
            const [polyPoints, setPolyPoints] = React.useState([]);
            const polyPointsRef = React.useRef([]);
            const [draggedPointIndex, setDraggedPointIndex] = React.useState(null);

            // Anchor adjustment enhancements
            const [hoveredPoint, setHoveredPoint] = React.useState(null); // {type, index}
            const [showGrid, setShowGrid] = React.useState(false);
            const [gridSize, setGridSize] = React.useState(20);
            const [snapToGrid, setSnapToGrid] = React.useState(false);
            const [dragStartPos, setDragStartPos] = React.useState(null); // For coordinate display
            const [keyModifiers, setKeyModifiers] = React.useState({ shift: false, ctrl: false, alt: false });

            // Manual Draw mode - now drops predefined shapes
            const [manualDrawMode, setManualDrawMode] = React.useState(false);
            const [manualDrawFeature, setManualDrawFeature] = React.useState('mouth');
            const [shapePreviewPos, setShapePreviewPos] = React.useState(null); // {x, y} for shape preview

            // Pinch-to-zoom state
            const lastPinchDistRef = React.useRef(null);
            const pinchCenterRef = React.useRef(null);

            // Double-tap detection for mobile
            const lastTapRef = React.useRef(null);

            const [isDraggingPoly, setIsDraggingPoly] = React.useState(false);
            const polyDragStartRef = React.useRef(null);
            const polyDragOrigRef = React.useRef(null);

            // Resize handle state
            const [isResizing, setIsResizing] = React.useState(false);
            const [resizingZone, setResizingZone] = React.useState(null); // {type: 'mouth'|'leftEye'|etc}
            const resizeStartRef = React.useRef(null); // {x, y, bounds, originalPoints}
            const RESIZE_HANDLE_SIZE = 32; // Increased for touch-friendly interaction

            // Eyes
            const [leftEyePoints, setLeftEyePoints] = React.useState([]);
            const leftEyePointsRef = React.useRef([]);
            const [rightEyePoints, setRightEyePoints] = React.useState([]);
            const rightEyePointsRef = React.useRef([]);

            // Eyebrows (separate polygons)
            const [leftBrowPoints, setLeftBrowPoints] = React.useState([]);
            const leftBrowPointsRef = React.useRef([]);
            const [rightBrowPoints, setRightBrowPoints] = React.useState([]);
            const rightBrowPointsRef = React.useRef([]);

            const [eyePresets, setEyePresets] = React.useState(['blink', 'wink_left', 'look_left', 'look_right']); // Selected eye presets to apply randomly
            const [draggedEye, setDraggedEye] = React.useState(null); // 'left', 'right', 'leftBrow', 'rightBrow'

            // Lip line (editable line following the split between upper and lower lips)
            const [lipLinePoints, setLipLinePoints] = React.useState([]);
            const lipLinePointsRef = React.useRef([]);


            // Zoom/Magnification for fine-tuning
            const [isZoomed, setIsZoomed] = React.useState(false);
            const [zoomScale, setZoomScale] = React.useState(1.0); // Start at 1.0 (no zoom)
            const [panOffset, setPanOffset] = React.useState({ x: 0, y: 0 });
            const [isPanning, setIsPanning] = React.useState(false);
            const panStartRef = React.useRef(null);
            const panOffsetStartRef = React.useRef(null);

            // Undo/Redo system
            const [history, setHistory] = React.useState([]);
            const [historyIndex, setHistoryIndex] = React.useState(-1);

            // Interaction
            const [activeTab, setActiveTab] = React.useState('audio');
            const [isAnimating, setIsAnimating] = React.useState(false);
            const [recordedVideo, setRecordedVideo] = React.useState(null);

            const [audioUrl, setAudioUrl] = React.useState(null);
            const [text, setText] = React.useState("Notice the 3D shape of the teeth and the bottom molars.");
            const [voices, setVoices] = React.useState([]);

            // Voice Recording
            const [isRecordingVoice, setIsRecordingVoice] = React.useState(false);
            const voiceRecorderRef = React.useRef(null);
            const voiceChunksRef = React.useRef([]);

            // Custom Voice Profile Controls
            const [voiceGender, setVoiceGender] = React.useState('male');
            const [voiceRate, setVoiceRate] = React.useState(0.95); // Speed: 0.1 to 2 (radio announcer slightly slower)
            const [voicePitch, setVoicePitch] = React.useState(0.9); // 0 to 2 (deeper pitch for male announcer)
            const [voiceVolume, setVoiceVolume] = React.useState(1.0); // 0 to 1
            const [voiceTimbre, setVoiceTimbre] = React.useState('warm'); // warm, neutral, bright
            const [voiceAccent, setVoiceAccent] = React.useState('neutral'); // neutral, british, american, australian
            const [savedVoiceProfiles, setSavedVoiceProfiles] = React.useState([]);

            // Params
            const [lipSplit, setLipSplit] = React.useState(0.5);
            const [lipWidth, setLipWidth] = React.useState(0.85);
            const [cupidBow, setCupidBow] = React.useState(0.3);
            const [lipCurve, setLipCurve] = React.useState(0.1);
            
            // 3D Anatomy Params
            const [teethBrightness, setTeethBrightness] = React.useState(0.9);
            const [teethShade, setTeethShade] = React.useState(0.2); // 0=White, 1=Yellow
            const [teethVertical, setTeethVertical] = React.useState(0);
            const [jawGap, setJawGap] = React.useState(0.1); // Spacing between top/bottom teeth
            const [tongueHeight, setTongueHeight] = React.useState(0.8); // Allowed to go higher
            const [lipLighten, setLipLighten] = React.useState(0.5);
            
            
            const [splitColor, setSplitColor] = React.useState(0.35);
            const [splitTexture, setSplitTexture] = React.useState(0.35);
            const [lipRoll, setLipRoll] = React.useState(0.35);
            const [syllableSnap, setSyllableSnap] = React.useState(0.5);
            const [sensitivity, setSensitivity] = React.useState(1.5);
            const [smoothing, setSmoothing] = React.useState(0.2);

            // Background Removal
            const [bgRemovalEnabled, setBgRemovalEnabled] = React.useState(false);
            const bgRemovalEnabledRef = React.useRef(false);
            const [bgRemovalThreshold, setBgRemovalThreshold] = React.useState(0.5);
            const [bgRemovalEdge, setBgRemovalEdge] = React.useState(0.1);
            const [isRemovingBg, setIsRemovingBg] = React.useState(false);

            // Background/Video
            const [backgroundType, setBackgroundType] = React.useState('none'); // 'none', 'color', 'image', 'video'
            const backgroundTypeRef = React.useRef('none');
            const [backgroundColor, setBackgroundColor] = React.useState('#000000');
            const backgroundColorRef = React.useRef('#000000');
            const [backgroundImage, setBackgroundImage] = React.useState(null);
            const [backgroundVideo, setBackgroundVideo] = React.useState(null);

            // Character positioning on background
            const [characterPosition, setCharacterPosition] = React.useState({ x: 0.5, y: 0.5, scale: 1.0 });
            const [isDraggingCharacter, setIsDraggingCharacter] = React.useState(false);

            // Audio source selection
            const [audioSource, setAudioSource] = React.useState('file'); // 'none', 'file', 'record', 'tts', 'video'

            // Export options
            const [exportWithAudio, setExportWithAudio] = React.useState(true);
            const [exportWithBackground, setExportWithBackground] = React.useState(true);

            const canvasRef = React.useRef(null);
            const imageRef = React.useRef(null);
            const audioRef = React.useRef(null);
            const animationFrameRef = React.useRef(null);
            const originalImageDataRef = React.useRef(null);
            const characterMaskRef = React.useRef(null); // Stores the segmented character with transparency
            const mouthTextureRef = React.useRef(null);
            const audioContextRef = React.useRef(null);
            const mediaRecorderRef = React.useRef(null);
            const chunksRef = React.useRef([]);
            const backgroundVideoRef = React.useRef(null);
            const segmenterRef = React.useRef(null);

            const params = React.useRef({});

            const draftKey = 'lipSyncDraft';

            const getBounds = (points) => {
                if(!points || points.length === 0) return {x:0,y:0,width:0,height:0};
                let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
                points.forEach(p => {
                    if(p.x < minX) minX = p.x; if(p.x > maxX) maxX = p.x;
                    if(p.y < minY) minY = p.y; if(p.y > maxY) maxY = p.y;
                });
                return { x: Math.floor(minX), y: Math.floor(minY), width: Math.ceil(maxX - minX), height: Math.ceil(maxY - minY) };
            };

            // Generate basic shapes for manual placement
            const generateBasicShape = (feature, centerX, centerY, canvasWidth, canvasHeight) => {
                // Scale shapes based on canvas size (assume face takes ~30% of image width)
                const baseScale = Math.min(canvasWidth, canvasHeight) * 0.15;
                const points = [];

                switch (feature) {
                    case 'mouth': {
                        // Oval mouth shape with 12 points
                        const w = baseScale * 1.2;
                        const h = baseScale * 0.6;
                        for (let i = 0; i < 12; i++) {
                            const angle = (i / 12) * Math.PI * 2;
                            points.push({
                                x: centerX + Math.cos(angle) * w,
                                y: centerY + Math.sin(angle) * h
                            });
                        }
                        break;
                    }
                    case 'leftEye':
                    case 'rightEye': {
                        // Almond-shaped eye with 6 points
                        const w = baseScale * 0.5;
                        const h = baseScale * 0.25;
                        // Create almond shape
                        points.push({ x: centerX - w, y: centerY }); // left corner
                        points.push({ x: centerX - w * 0.5, y: centerY - h }); // top left
                        points.push({ x: centerX + w * 0.5, y: centerY - h }); // top right
                        points.push({ x: centerX + w, y: centerY }); // right corner
                        points.push({ x: centerX + w * 0.5, y: centerY + h * 0.7 }); // bottom right
                        points.push({ x: centerX - w * 0.5, y: centerY + h * 0.7 }); // bottom left
                        break;
                    }
                    case 'leftBrow':
                    case 'rightBrow': {
                        // Curved eyebrow with 5 points
                        const w = baseScale * 0.6;
                        const h = baseScale * 0.15;
                        const flip = feature === 'rightBrow' ? -1 : 1;
                        points.push({ x: centerX - w, y: centerY + h * 0.5 * flip });
                        points.push({ x: centerX - w * 0.5, y: centerY - h * flip });
                        points.push({ x: centerX, y: centerY - h * 1.2 * flip });
                        points.push({ x: centerX + w * 0.5, y: centerY - h * 0.8 * flip });
                        points.push({ x: centerX + w, y: centerY });
                        break;
                    }
                    default:
                        break;
                }
                return points;
            };

            // --- UNDO/REDO SYSTEM ---
            const saveToHistory = () => {
                const state = {
                    polyPoints: JSON.parse(JSON.stringify(polyPoints)),
                    lipLinePoints: JSON.parse(JSON.stringify(lipLinePoints)),
                    leftEyePoints: JSON.parse(JSON.stringify(leftEyePoints)),
                    rightEyePoints: JSON.parse(JSON.stringify(rightEyePoints)),
                    leftBrowPoints: JSON.parse(JSON.stringify(leftBrowPoints)),
                    rightBrowPoints: JSON.parse(JSON.stringify(rightBrowPoints))
                };

                // Truncate history if we're not at the end
                const newHistory = history.slice(0, historyIndex + 1);
                newHistory.push(state);

                // Keep only last 15 states
                if (newHistory.length > 15) {
                    newHistory.shift();
                }

                setHistory(newHistory);
                setHistoryIndex(newHistory.length - 1);

                // Save to localStorage
                try {
                    localStorage.setItem('lipSyncHistory', JSON.stringify(newHistory));
                } catch (e) {
                    console.error('Failed to save history to localStorage:', e);
                }
            };

            const undo = () => {
                if (historyIndex > 0) {
                    const prevIndex = historyIndex - 1;
                    const state = history[prevIndex];
                    setPolyPoints(state.polyPoints);
                    setLipLinePoints(state.lipLinePoints || []);
                    setLeftEyePoints(state.leftEyePoints || []);
                    setRightEyePoints(state.rightEyePoints || []);
                    setLeftBrowPoints(state.leftBrowPoints || []);
                    setRightBrowPoints(state.rightBrowPoints || []);
                    setHistoryIndex(prevIndex);
                }
            };

            const redo = () => {
                if (historyIndex < history.length - 1) {
                    const nextIndex = historyIndex + 1;
                    const state = history[nextIndex];
                    setPolyPoints(state.polyPoints);
                    setLipLinePoints(state.lipLinePoints || []);
                    setLeftEyePoints(state.leftEyePoints || []);
                    setRightEyePoints(state.rightEyePoints || []);
                    setLeftBrowPoints(state.leftBrowPoints || []);
                    setRightBrowPoints(state.rightBrowPoints || []);
                    setHistoryIndex(nextIndex);
                }
            };

            // --- BACKGROUND REMOVAL ---
            const initSegmenter = async () => {
                if (segmenterRef.current) return segmenterRef.current;

                try {
                    const segmenter = new SelfieSegmentation({
                        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}`
                    });
                    segmenter.setOptions({ modelSelection: 1, selfieMode: false });
                    await segmenter.initialize();
                    segmenterRef.current = segmenter;
                    return segmenter;
                } catch (e) {
                    console.error('Failed to initialize segmenter:', e);
                    return null;
                }
            };

            const removeBackground = async () => {
                if (!image || !canvasRef.current) return;

                setIsRemovingBg(true);
                setStatus('Removing background...');

                try {
                    const segmenter = await initSegmenter();
                    if (!segmenter) {
                        setStatus('Background removal not available');
                        setIsRemovingBg(false);
                        return;
                    }

                    // Create a temporary canvas with the original image
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = canvasRef.current.width;
                    tempCanvas.height = canvasRef.current.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    if (originalImageDataRef.current) {
                        tempCtx.putImageData(originalImageDataRef.current, 0, 0);
                    }

                    // Run segmentation
                    const results = await new Promise((resolve) => {
                        segmenter.onResults(resolve);
                        segmenter.send({ image: tempCanvas });
                    });

                    if (results.segmentationMask) {
                        // Create character mask with transparency
                        const maskCanvas = document.createElement('canvas');
                        maskCanvas.width = tempCanvas.width;
                        maskCanvas.height = tempCanvas.height;
                        const maskCtx = maskCanvas.getContext('2d');

                        // Draw the original image
                        maskCtx.drawImage(tempCanvas, 0, 0);

                        // Get the image data
                        const imageData = maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height);
                        const maskData = results.segmentationMask;

                        // Create a temporary canvas to read the mask
                        const maskReadCanvas = document.createElement('canvas');
                        maskReadCanvas.width = maskCanvas.width;
                        maskReadCanvas.height = maskCanvas.height;
                        const maskReadCtx = maskReadCanvas.getContext('2d');
                        maskReadCtx.drawImage(maskData, 0, 0, maskCanvas.width, maskCanvas.height);
                        const maskPixels = maskReadCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height).data;

                        // Apply mask with threshold and edge softening
                        for (let i = 0; i < imageData.data.length; i += 4) {
                            const maskValue = maskPixels[i] / 255; // 0-1

                            // Apply threshold
                            let alpha;
                            if (maskValue > bgRemovalThreshold + bgRemovalEdge) {
                                alpha = 255;
                            } else if (maskValue < bgRemovalThreshold - bgRemovalEdge) {
                                alpha = 0;
                            } else {
                                // Smooth edge transition
                                alpha = Math.round(((maskValue - (bgRemovalThreshold - bgRemovalEdge)) / (bgRemovalEdge * 2)) * 255);
                            }

                            imageData.data[i + 3] = alpha;
                        }

                        maskCtx.putImageData(imageData, 0, 0);
                        characterMaskRef.current = maskCanvas;
                        bgRemovalEnabledRef.current = true;
                        setBgRemovalEnabled(true);
                        setStatus('Background removed. Adjust threshold/edge if needed.');
                        drawOverlay();
                    }
                } catch (e) {
                    console.error('Background removal failed:', e);
                    setStatus('Background removal failed: ' + e.message);
                }

                setIsRemovingBg(false);
            };

            const resetBackgroundRemoval = () => {
                characterMaskRef.current = null;
                bgRemovalEnabledRef.current = false;
                setBgRemovalEnabled(false);
                drawOverlay();
            };

            // --- BACKGROUND IMAGE/VIDEO LOADING ---
            const handleBackgroundImageUpload = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (ev) => {
                    const img = new Image();
                    img.onload = () => {
                        setBackgroundImage(img);
                        backgroundTypeRef.current = 'image';
                        setBackgroundType('image');
                        setStatus('Background image loaded');
                        drawOverlay();
                    };
                    img.src = ev.target.result;
                };
                reader.readAsDataURL(file);
            };

            const handleBackgroundVideoUpload = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const videoUrl = URL.createObjectURL(file);
                const video = document.createElement('video');
                video.src = videoUrl;
                video.muted = true;
                video.loop = true;
                video.preload = 'auto';

                video.onloadedmetadata = () => {
                    setBackgroundVideo(video);
                    backgroundVideoRef.current = video;
                    backgroundTypeRef.current = 'video';
                    setBackgroundType('video');
                    setStatus('Background video loaded');

                    // Also extract audio from video if audio source is 'video'
                    if (audioSource === 'video') {
                        const audioVideo = document.createElement('video');
                        audioVideo.src = videoUrl;
                        audioVideo.preload = 'auto';
                        setAudioUrl(videoUrl);
                    }

                    video.play().catch(() => {});
                    drawOverlay();
                };
                video.load();
            };

            const clearBackground = () => {
                if (backgroundVideoRef.current) {
                    backgroundVideoRef.current.pause();
                    backgroundVideoRef.current.src = '';
                }
                setBackgroundImage(null);
                setBackgroundVideo(null);
                backgroundTypeRef.current = 'none';
                setBackgroundType('none');
                backgroundVideoRef.current = null;
                drawOverlay();
            };

            // Load history from localStorage on mount
            React.useEffect(() => {
                try {
                    const savedHistory = localStorage.getItem('lipSyncHistory');
                    if (savedHistory) {
                        const parsed = JSON.parse(savedHistory);
                        setHistory(parsed);
                        setHistoryIndex(parsed.length - 1);
                    }
                } catch (e) {
                    console.error('Failed to load history from localStorage:', e);
                }
            }, []);

            // Keep refs in sync with state for immediate rendering
            React.useEffect(() => { polyPointsRef.current = polyPoints; }, [polyPoints]);
            React.useEffect(() => { leftEyePointsRef.current = leftEyePoints; }, [leftEyePoints]);
            React.useEffect(() => { rightEyePointsRef.current = rightEyePoints; }, [rightEyePoints]);
            React.useEffect(() => { leftBrowPointsRef.current = leftBrowPoints; }, [leftBrowPoints]);
            React.useEffect(() => { rightBrowPointsRef.current = rightBrowPoints; }, [rightBrowPoints]);
            React.useEffect(() => { lipLinePointsRef.current = lipLinePoints; }, [lipLinePoints]);
            React.useEffect(() => { bgRemovalEnabledRef.current = bgRemovalEnabled; }, [bgRemovalEnabled]);
            React.useEffect(() => { backgroundTypeRef.current = backgroundType; }, [backgroundType]);
            React.useEffect(() => { backgroundColorRef.current = backgroundColor; }, [backgroundColor]);

            // Keyboard event listeners for modifier keys
            React.useEffect(() => {
                const handleKeyDown = (e) => {
                    setKeyModifiers(prev => ({
                        shift: e.shiftKey,
                        ctrl: e.ctrlKey || e.metaKey,
                        alt: e.altKey
                    }));

                    // Toggle grid with 'G' key
                    if (e.key === 'g' || e.key === 'G') {
                        setShowGrid(prev => !prev);
                    }
                    // Toggle snap with 'S' key
                    if ((e.key === 's' || e.key === 'S') && e.ctrlKey) {
                        e.preventDefault();
                        setSnapToGrid(prev => !prev);
                    }
                };

                const handleKeyUp = (e) => {
                    setKeyModifiers(prev => ({
                        shift: e.shiftKey,
                        ctrl: e.ctrlKey || e.metaKey,
                        alt: e.altKey
                    }));
                };

                window.addEventListener('keydown', handleKeyDown);
                window.addEventListener('keyup', handleKeyUp);
                return () => {
                    window.removeEventListener('keydown', handleKeyDown);
                    window.removeEventListener('keyup', handleKeyUp);
                };
            }, []);

            React.useEffect(() => {
                params.current = { lipSplit, lipWidth, cupidBow, lipCurve, teethBrightness, teethShade, teethVertical, jawGap, tongueHeight, lipLighten, splitColor, splitTexture, sensitivity, smoothing, lipRoll, syllableSnap };
                if (polyPoints.length > 2 && !isAnimating) {
                    const bounds = getBounds(polyPoints);
                    generateMouthTexture(bounds.width, bounds.height);

                    // Regenerate lip line when relevant parameters change
                    const newLipLine = generateLipLine(bounds);
                    if (newLipLine.length > 0) {
                        setLipLinePoints(newLipLine);
                    }

                    drawOverlay();
                }
            }, [lipSplit, lipWidth, cupidBow, lipCurve, teethBrightness, teethShade, teethVertical, jawGap, tongueHeight, lipLighten, splitColor, splitTexture, sensitivity, smoothing, lipRoll, syllableSnap, polyPoints, leftEyePoints, rightEyePoints, isZoomed, zoomScale, panOffset]);

            React.useEffect(() => {
                const init = async () => {
                    try {
                        const URL = 'https://cdn.jsdelivr.net/npm/@vladmandic/face-api/model';
                        await Promise.all([
                            faceapi.nets.tinyFaceDetector.loadFromUri(URL),
                            faceapi.nets.faceLandmark68Net.loadFromUri(URL)
                        ]);
                        setModelsLoaded(true);
                    } catch(e) { setStatus("AI Failed. Use Manual."); }
                    const getVoices = () => setVoices(window.speechSynthesis.getVoices());
                    getVoices(); window.speechSynthesis.onvoiceschanged = getVoices;
                };
                init();
                return () => stopEverything();
            }, []);

            // Load draft on mount
            React.useEffect(() => {
                const saved = localStorage.getItem(draftKey);
                if (saved) {
                    const data = JSON.parse(saved);
                    setLipSplit(data.lipSplit || 0.5);
                    setLipWidth(data.lipWidth || 0.85);
                    setCupidBow(data.cupidBow || 0.3);
                    setLipCurve(data.lipCurve || 0.1);
                    setTeethBrightness(data.teethBrightness || 0.9);
                    setTeethShade(data.teethShade || 0.2);
                    setTeethVertical(data.teethVertical || 0);
                    setJawGap(data.jawGap || 0.1);
                    setTongueHeight(data.tongueHeight || 0.8);
                    setLipLighten(data.lipLighten || 0.5);
                    setSplitColor(data.splitColor || 0.35);
                    setSplitTexture(data.splitTexture || 0.35);
                    setLipRoll(data.lipRoll || 0.35);
                    setSyllableSnap(data.syllableSnap || 0.5);
                    setSensitivity(data.sensitivity || 1.5);
                    setSmoothing(data.smoothing || 0.2);
                    setPolyPoints(data.polyPoints || []);
                    setLipLinePoints(data.lipLinePoints || []);
                    setLeftEyePoints(data.leftEyePoints || []);
                    setRightEyePoints(data.rightEyePoints || []);
                    setEyePresets(data.eyePresets || ['blink', 'wink_left', 'look_left', 'look_right']);
                    setVoiceGender(data.voiceGender || 'male');
                    setVoiceRate(data.voiceRate || 0.95);
                    setVoicePitch(data.voicePitch || 0.9);
                    setVoiceVolume(data.voiceVolume || 1.0);
                    setVoiceTimbre(data.voiceTimbre || 'warm');
                    setVoiceAccent(data.voiceAccent || 'neutral');
                    setSavedVoiceProfiles(data.savedVoiceProfiles || []);
                    setText(data.text || "Notice the 3D shape of the teeth and the bottom molars.");
                    // AudioUrl and image not saved as they are large/blobs
                }
            }, []);

            const saveDraft = () => {
                const data = {
                    lipSplit, lipWidth, cupidBow, lipCurve, teethBrightness, teethShade, teethVertical, jawGap, tongueHeight, lipLighten,
                    splitColor, splitTexture, lipRoll, syllableSnap, sensitivity, smoothing,
                    polyPoints, lipLinePoints, leftEyePoints, rightEyePoints,
                    eyePresets, voiceGender, voiceRate, voicePitch, voiceVolume, voiceTimbre, voiceAccent, savedVoiceProfiles, text
                };
                localStorage.setItem(draftKey, JSON.stringify(data));
                setStatus("Draft saved!");
            };

            const clearDraft = () => {
                localStorage.removeItem(draftKey);
                setStatus("Draft cleared.");
            };

            // Voice Profile Management
            const saveVoiceProfile = (profileName) => {
                if (!profileName || profileName.trim() === '') {
                    setStatus("Please enter a profile name");
                    return;
                }

                const profile = {
                    name: profileName.trim(),
                    gender: voiceGender,
                    rate: voiceRate,
                    pitch: voicePitch,
                    volume: voiceVolume,
                    timbre: voiceTimbre,
                    accent: voiceAccent,
                    timestamp: Date.now()
                };

                const updatedProfiles = [...savedVoiceProfiles.filter(p => p.name !== profileName.trim()), profile];
                setSavedVoiceProfiles(updatedProfiles);
                setStatus(`Voice profile "${profileName}" saved!`);

                // Also save to draft
                saveDraft();
            };

            const loadVoiceProfile = (profile) => {
                setVoiceGender(profile.gender);
                setVoiceRate(profile.rate);
                setVoicePitch(profile.pitch);
                setVoiceVolume(profile.volume);
                setVoiceTimbre(profile.timbre);
                setVoiceAccent(profile.accent);
                setStatus(`Voice profile "${profile.name}" loaded!`);
            };

            const deleteVoiceProfile = (profileName) => {
                setSavedVoiceProfiles(savedVoiceProfiles.filter(p => p.name !== profileName));
                setStatus(`Voice profile "${profileName}" deleted!`);
            };

            const exportVoiceProfile = (profile) => {
                const dataStr = JSON.stringify(profile, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `voice-profile-${profile.name}.json`;
                link.click();
                URL.revokeObjectURL(url);
                setStatus(`Voice profile "${profile.name}" exported!`);
            };

            const importVoiceProfile = (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const profile = JSON.parse(e.target.result);
                        if (profile.name && profile.gender && profile.rate !== undefined) {
                            const updatedProfiles = [...savedVoiceProfiles.filter(p => p.name !== profile.name), profile];
                            setSavedVoiceProfiles(updatedProfiles);
                            setStatus(`Voice profile "${profile.name}" imported!`);
                        } else {
                            setStatus("Invalid voice profile file");
                        }
                    } catch (err) {
                        setStatus("Error reading voice profile file");
                    }
                };
                reader.readAsText(file);
            };

            // Voice Recording
            const startVoiceRecord = async () => {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    const recorder = new MediaRecorder(stream);
                    voiceRecorderRef.current = recorder;
                    voiceChunksRef.current = [];
                    recorder.ondataavailable = (e) => voiceChunksRef.current.push(e.data);
                    recorder.onstop = () => {
                        const blob = new Blob(voiceChunksRef.current, { type: 'audio/webm' });
                        setAudioUrl(URL.createObjectURL(blob));
                        setStatus("Voice recorded!");
                    };
                    recorder.start();
                    setIsRecordingVoice(true);
                } catch (e) {
                    setStatus("Microphone access denied.");
                    console.error(e);
                }
            };

            const stopVoiceRecord = () => {
                if (voiceRecorderRef.current) {
                    voiceRecorderRef.current.stop();
                    setIsRecordingVoice(false);
                }
            };

            // --- INTERACTION ---
            const getCoords = (e) => {
                const rect = canvasRef.current.getBoundingClientRect();
                const scaleX = canvasRef.current.width / rect.width;
                const scaleY = canvasRef.current.height / rect.height;

                let canvasX, canvasY;

                // Handle touch events (check both touches and changedTouches for touch end events)
                if (e.touches && e.touches.length > 0) {
                    canvasX = (e.touches[0].clientX - rect.left) * scaleX;
                    canvasY = (e.touches[0].clientY - rect.top) * scaleY;
                } else if (e.changedTouches && e.changedTouches.length > 0) {
                    canvasX = (e.changedTouches[0].clientX - rect.left) * scaleX;
                    canvasY = (e.changedTouches[0].clientY - rect.top) * scaleY;
                } else {
                    canvasX = (e.clientX - rect.left) * scaleX;
                    canvasY = (e.clientY - rect.top) * scaleY;
                }

                // If zoomed, transform coordinates back to original image space
                if (isZoomed && zoomScale > 1.0) {
                    const imageWidth = canvasRef.current.width;
                    const imageHeight = canvasRef.current.height;

                    // Calculate the zoomed viewport dimensions
                    const viewportWidth = imageWidth / zoomScale;
                    const viewportHeight = imageHeight / zoomScale;

                    // Transform canvas coordinates to image coordinates
                    const imageX = (canvasX / imageWidth) * viewportWidth + panOffset.x;
                    const imageY = (canvasY / imageHeight) * viewportHeight + panOffset.y;

                    return { x: imageX, y: imageY };
                }

                return { x: canvasX, y: canvasY };
            };

            const isNearPoint = (p, target, radius=28) => Math.sqrt(Math.pow(p.x - target.x, 2) + Math.pow(p.y - target.y, 2)) < radius;

            const distToSegment = (p, a, b) => {
                const l2 = Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2);
                if (l2 === 0) return Math.sqrt(Math.pow(p.x - a.x, 2) + Math.pow(p.y - a.y, 2));
                let t = ((p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y)) / l2;
                t = Math.max(0, Math.min(1, t));
                const proj = { x: a.x + t * (b.x - a.x), y: a.y + t * (b.y - a.y) };
                return Math.sqrt(Math.pow(p.x - proj.x, 2) + Math.pow(p.y - proj.y, 2));
            };

            const pointInPoly = (pt, poly) => {
                if (!poly || poly.length < 3) return false;
                let inside = false;
                for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
                    const xi = poly[i].x, yi = poly[i].y;
                    const xj = poly[j].x, yj = poly[j].y;
                    const intersect = ((yi > pt.y) !== (yj > pt.y)) &&
                        (pt.x < (xj - xi) * (pt.y - yi) / ((yj - yi) || 1e-9) + xi);
                    if (intersect) inside = !inside;
                }
                return inside;
            };

            // Get resize handle position (bottom-right corner of bounding box)
            const getResizeHandlePos = (points) => {
                if (!points || points.length < 3) return null;
                const bounds = getBounds(points);
                return { x: bounds.x + bounds.width, y: bounds.y + bounds.height };
            };

            // Check if a point is on a resize handle
            const isOnResizeHandle = (pt, points) => {
                const handlePos = getResizeHandlePos(points);
                if (!handlePos) return false;
                const handleRadius = getHitRadius(RESIZE_HANDLE_SIZE);
                return Math.sqrt(Math.pow(pt.x - handlePos.x, 2) + Math.pow(pt.y - handlePos.y, 2)) < handleRadius;
            };

            // Check all zones for resize handle click
            const findResizeHandle = (pt) => {
                const zones = [
                    { type: 'mouth', points: polyPointsRef.current },
                    { type: 'leftEye', points: leftEyePointsRef.current },
                    { type: 'rightEye', points: rightEyePointsRef.current },
                    { type: 'leftBrow', points: leftBrowPointsRef.current },
                    { type: 'rightBrow', points: rightBrowPointsRef.current }
                ];
                for (const zone of zones) {
                    if (zone.points.length > 0 && isOnResizeHandle(pt, zone.points)) {
                        return zone;
                    }
                }
                return null;
            };

            // Scale points from center
            const scaleZone = (originalPoints, originalBounds, newBottomRight) => {
                const centerX = originalBounds.x + originalBounds.width / 2;
                const centerY = originalBounds.y + originalBounds.height / 2;

                const newWidth = (newBottomRight.x - originalBounds.x);
                const newHeight = (newBottomRight.y - originalBounds.y);

                const scaleX = newWidth / originalBounds.width;
                const scaleY = newHeight / originalBounds.height;

                // Use uniform scaling (average of X and Y)
                const scale = (scaleX + scaleY) / 2;

                return originalPoints.map(p => ({
                    x: centerX + (p.x - centerX) * scale,
                    y: centerY + (p.y - centerY) * scale
                }));
            };

            // Snap point to grid
            const snapPoint = (point, gridSize) => {
                if (!snapToGrid) return point;
                return {
                    x: Math.round(point.x / gridSize) * gridSize,
                    y: Math.round(point.y / gridSize) * gridSize
                };
            };

            // Apply axis constraint (Shift key)
            const applyAxisConstraint = (newPos, startPos, shiftPressed) => {
                if (!shiftPressed || !startPos) return newPos;
                const dx = Math.abs(newPos.x - startPos.x);
                const dy = Math.abs(newPos.y - startPos.y);
                // Lock to dominant axis
                if (dx > dy) {
                    return { x: newPos.x, y: startPos.y };
                } else {
                    return { x: startPos.x, y: newPos.y };
                }
            };

            // Apply precision mode (Ctrl key)
            const applyPrecisionMode = (delta, ctrlPressed) => {
                const factor = ctrlPressed ? 0.25 : 1.0; // 25% speed for precision
                return { x: delta.x * factor, y: delta.y * factor };
            };

            // Helper function to transform points from image space to canvas space when zoomed
            // Defined at component level so it can be used in event handlers
            const transformPointToCanvas = (p, zoomed, scale, offset) => {
                if (!zoomed || scale <= 1.0 || !canvasRef.current) return p;

                const imageWidth = canvasRef.current.width;
                const imageHeight = canvasRef.current.height;
                const viewportWidth = imageWidth / scale;
                const viewportHeight = imageHeight / scale;

                const canvasX = ((p.x - offset.x) / viewportWidth) * imageWidth;
                const canvasY = ((p.y - offset.y) / viewportHeight) * imageHeight;

                return { x: canvasX, y: canvasY };
            };

            // Get hit detection radius adjusted for zoom level
            // When zoomed in, we need larger hit areas in image space since the view is magnified
            const getHitRadius = (baseRadius) => {
                if (isZoomed && zoomScale > 1.0) {
                    return baseRadius / zoomScale;
                }
                return baseRadius;
            };

            // Get anchor point rendering radius adjusted for zoom level
            // When zoomed in, anchor points need to be drawn larger in canvas space
            // to maintain consistent screen size
            const getAnchorRadius = (baseRadius = 12) => {
                if (isZoomed && zoomScale > 1.0) {
                    return baseRadius * zoomScale;
                }
                return baseRadius;
            };

            const generateLipLine = (mouthBounds) => {
                if (!mouthBounds || !polyPoints.length) return [];

                const b = mouthBounds;
                const lipW = b.width * params.current.lipWidth;
                const lx = b.x + (b.width - lipW) / 2;
                const cx = b.x + b.width / 2;
                const baseSplitY = b.y + (b.height * params.current.lipSplit);

                // Generate 15 points along the lip line following the contour
                const points = [];
                const numPoints = 15;
                for (let i = 0; i < numPoints; i++) {
                    const t = i / (numPoints - 1); // 0 to 1
                    const x = lx + t * lipW;
                    const nx = (x - cx) / (lipW / 2);

                    // Same curve calculation as the old guide
                    const mainCurve = (nx * nx) * params.current.lipCurve * (b.height * 0.1);
                    const bow = Math.cos(nx * Math.PI * 2.5) * params.current.cupidBow * (b.height * 0.05);
                    const bowFaded = bow * Math.max(0, 1 - Math.abs(nx * 1.5));
                    const y = baseSplitY - mainCurve - bowFaded;

                    points.push({ x, y });
                }

                return points;
            };

            const findClickedPolygon = (point) => {
                // Check which polygon (if any) was clicked
                // Returns {type: 'mouth'|'leftEye'|'rightEye'|'leftBrow'|'rightBrow'|'lipLine', points: array, pointIndex: number}

                const pointRadius = getHitRadius(28);

                // Check mouth points - use refs for current values
                const mouthIdx = polyPointsRef.current.findIndex(p => isNearPoint(p, point, pointRadius));
                if (mouthIdx !== -1) return { type: 'mouth', points: polyPointsRef.current, pointIndex: mouthIdx };

                // Check lip line points - use refs for current values
                const lipLineIdx = lipLinePointsRef.current.findIndex(p => isNearPoint(p, point, pointRadius));
                if (lipLineIdx !== -1) return { type: 'lipLine', points: lipLinePointsRef.current, pointIndex: lipLineIdx };

                // Check left eye points - use refs for current values
                const leftEyeIdx = leftEyePointsRef.current.findIndex(p => isNearPoint(p, point, pointRadius));
                if (leftEyeIdx !== -1) return { type: 'leftEye', points: leftEyePointsRef.current, pointIndex: leftEyeIdx };

                // Check right eye points - use refs for current values
                const rightEyeIdx = rightEyePointsRef.current.findIndex(p => isNearPoint(p, point, pointRadius));
                if (rightEyeIdx !== -1) return { type: 'rightEye', points: rightEyePointsRef.current, pointIndex: rightEyeIdx };

                // Check left eyebrow points - use refs for current values
                const leftBrowIdx = leftBrowPointsRef.current.findIndex(p => isNearPoint(p, point, pointRadius));
                if (leftBrowIdx !== -1) return { type: 'leftBrow', points: leftBrowPointsRef.current, pointIndex: leftBrowIdx };

                // Check right eyebrow points - use refs for current values
                const rightBrowIdx = rightBrowPointsRef.current.findIndex(p => isNearPoint(p, point, pointRadius));
                if (rightBrowIdx !== -1) return { type: 'rightBrow', points: rightBrowPointsRef.current, pointIndex: rightBrowIdx };

                // Check if inside polygons (for dragging whole polygon) - use refs for current values
                if (polyPointsRef.current.length > 2 && pointInPoly(point, polyPointsRef.current)) return { type: 'mouth', points: polyPointsRef.current, pointIndex: -1 };
                if (leftEyePointsRef.current.length > 2 && pointInPoly(point, leftEyePointsRef.current)) return { type: 'leftEye', points: leftEyePointsRef.current, pointIndex: -1 };
                if (rightEyePointsRef.current.length > 2 && pointInPoly(point, rightEyePointsRef.current)) return { type: 'rightEye', points: rightEyePointsRef.current, pointIndex: -1 };
                if (leftBrowPointsRef.current.length > 2 && pointInPoly(point, leftBrowPointsRef.current)) return { type: 'leftBrow', points: leftBrowPointsRef.current, pointIndex: -1 };
                if (rightBrowPointsRef.current.length > 2 && pointInPoly(point, rightBrowPointsRef.current)) return { type: 'rightBrow', points: rightBrowPointsRef.current, pointIndex: -1 };

                return null;
            };

            const updatePolygon = (type, newPoints) => {
                // Update refs synchronously first for immediate drawOverlay() calls
                if (type === 'mouth') {
                    polyPointsRef.current = newPoints;
                    setPolyPoints(newPoints);
                } else if (type === 'lipLine') {
                    lipLinePointsRef.current = newPoints;
                    setLipLinePoints(newPoints);
                } else if (type === 'leftEye') {
                    leftEyePointsRef.current = newPoints;
                    setLeftEyePoints(newPoints);
                } else if (type === 'rightEye') {
                    rightEyePointsRef.current = newPoints;
                    setRightEyePoints(newPoints);
                } else if (type === 'leftBrow') {
                    leftBrowPointsRef.current = newPoints;
                    setLeftBrowPoints(newPoints);
                } else if (type === 'rightBrow') {
                    rightBrowPointsRef.current = newPoints;
                    setRightBrowPoints(newPoints);
                }
            };

            const handleMouseDown = (e) => {
                if (isAnimating || !image) return;

                // For manual draw mode - drop predefined shape on click
                if (manualDrawMode) {
                    const m = getCoords(e);
                    const cw = canvasRef.current.width;
                    const ch = canvasRef.current.height;

                    // Generate and place the shape at click position
                    const shapePoints = generateBasicShape(manualDrawFeature, m.x, m.y, cw, ch);

                    if (shapePoints.length > 0) {
                        // Use feature name directly as polygon type
                        updatePolygon(manualDrawFeature, shapePoints);

                        // Generate lip line if placing mouth
                        if (manualDrawFeature === 'mouth') {
                            const mouthBounds = getBounds(shapePoints);
                            setLipLinePoints(generateLipLine(mouthBounds));
                        }

                        saveToHistory();
                        setManualDrawMode(false);
                        setShapePreviewPos(null);
                        setStatus(`${manualDrawFeature} placed. Drag points to refine, double-click edge to add points.`);
                        drawOverlay();
                    }
                    return;
                }

                const m = getCoords(e);

                // Check if we clicked on a resize handle first
                const resizeHandle = findResizeHandle(m);
                if (resizeHandle) {
                    setIsResizing(true);
                    setResizingZone(resizeHandle.type);
                    resizeStartRef.current = {
                        x: m.x,
                        y: m.y,
                        bounds: getBounds(resizeHandle.points),
                        originalPoints: resizeHandle.points.map(p => ({ ...p }))
                    };
                    return;
                }

                const clicked = findClickedPolygon(m);

                // Check if we clicked on a polygon or point
                if (clicked) {
                    if (clicked.pointIndex !== -1) {
                        // Clicked on a point - start dragging it
                        setDraggedPointIndex(clicked.pointIndex);
                        setDraggedEye(clicked.type);
                        setDragStartPos(clicked.points[clicked.pointIndex]); // Store original position
                    } else {
                        // Clicked inside polygon - drag whole polygon
                        setIsDraggingPoly(true);
                        setDraggedEye(clicked.type);
                        polyDragStartRef.current = m;
                        polyDragOrigRef.current = clicked.points.map(p => ({ ...p }));
                    }
                    return;
                }

                // No polygon clicked - start panning if zoomed
                if (zoomScale > 1.0) {
                    setIsPanning(true);
                    const rect = canvasRef.current.getBoundingClientRect();
                    const scaleX = canvasRef.current.width / rect.width;
                    const scaleY = canvasRef.current.height / rect.height;
                    if (e.touches && e.touches.length > 0) {
                        panStartRef.current = {
                            x: (e.touches[0].clientX - rect.left) * scaleX,
                            y: (e.touches[0].clientY - rect.top) * scaleY
                        };
                    } else {
                        panStartRef.current = {
                            x: (e.clientX - rect.left) * scaleX,
                            y: (e.clientY - rect.top) * scaleY
                        };
                    }
                    panOffsetStartRef.current = { ...panOffset };
                }
            };

            const handleMouseMove = (e) => {
                if (!image) return;

                // Handle panning when zoomed
                if (isPanning && panStartRef.current && panOffsetStartRef.current) {
                    const rect = canvasRef.current.getBoundingClientRect();
                    const scaleX = canvasRef.current.width / rect.width;
                    const scaleY = canvasRef.current.height / rect.height;

                    let currentX, currentY;
                    if (e.touches && e.touches.length > 0) {
                        currentX = (e.touches[0].clientX - rect.left) * scaleX;
                        currentY = (e.touches[0].clientY - rect.top) * scaleY;
                    } else {
                        currentX = (e.clientX - rect.left) * scaleX;
                        currentY = (e.clientY - rect.top) * scaleY;
                    }

                    const dx = currentX - panStartRef.current.x;
                    const dy = currentY - panStartRef.current.y;

                    const imageWidth = canvasRef.current.width;
                    const imageHeight = canvasRef.current.height;
                    const viewportWidth = imageWidth / zoomScale;
                    const viewportHeight = imageHeight / zoomScale;

                    // Convert canvas pixel movement to image space movement
                    const imageDx = (dx / imageWidth) * viewportWidth;
                    const imageDy = (dy / imageHeight) * viewportHeight;

                    let newPanX = panOffsetStartRef.current.x - imageDx;
                    let newPanY = panOffsetStartRef.current.y - imageDy;

                    // Clamp pan offset to keep image within bounds
                    newPanX = Math.max(0, Math.min(imageWidth - viewportWidth, newPanX));
                    newPanY = Math.max(0, Math.min(imageHeight - viewportHeight, newPanY));

                    setPanOffset({ x: newPanX, y: newPanY });
                    drawOverlay();
                    return;
                }

                const m = getCoords(e);

                // Handle resizing
                if (isResizing && resizeStartRef.current && resizingZone) {
                    const newBottomRight = { x: m.x, y: m.y };
                    const scaledPoints = scaleZone(
                        resizeStartRef.current.originalPoints,
                        resizeStartRef.current.bounds,
                        newBottomRight
                    );
                    updatePolygon(resizingZone, scaledPoints);
                    drawOverlay();
                    canvasRef.current.style.cursor = 'nwse-resize';
                    return;
                }

                // Manual draw mode - show shape preview following cursor
                if (manualDrawMode) {
                    setShapePreviewPos(m);
                    drawOverlay();

                    // Draw shape preview at cursor position
                    const ctx = canvasRef.current.getContext('2d');
                    const cw = canvasRef.current.width;
                    const ch = canvasRef.current.height;
                    const previewPoints = generateBasicShape(manualDrawFeature, m.x, m.y, cw, ch);

                    if (previewPoints.length > 0) {
                        ctx.strokeStyle = 'rgba(255, 153, 0, 0.7)';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([6, 4]);
                        ctx.beginPath();

                        const firstPt = transformPointToCanvas(previewPoints[0], zoomScale > 1.0, zoomScale, panOffset);
                        ctx.moveTo(firstPt.x, firstPt.y);

                        for (let i = 1; i < previewPoints.length; i++) {
                            const pt = transformPointToCanvas(previewPoints[i], zoomScale > 1.0, zoomScale, panOffset);
                            ctx.lineTo(pt.x, pt.y);
                        }
                        ctx.closePath();
                        ctx.stroke();
                        ctx.setLineDash([]);

                        // Draw preview anchor points
                        ctx.fillStyle = 'rgba(255, 153, 0, 0.5)';
                        previewPoints.forEach(p => {
                            const pt = transformPointToCanvas(p, zoomScale > 1.0, zoomScale, panOffset);
                            ctx.beginPath();
                            ctx.arc(pt.x, pt.y, 6, 0, Math.PI * 2);
                            ctx.fill();
                        });
                    }

                    canvasRef.current.style.cursor = 'crosshair';
                    return;
                }

                if (isDraggingPoly && polyDragStartRef.current && polyDragOrigRef.current && draggedEye) {
                    let dx = m.x - polyDragStartRef.current.x;
                    let dy = m.y - polyDragStartRef.current.y;

                    // Apply precision mode (Ctrl key)
                    const precisionDelta = applyPrecisionMode({ x: dx, y: dy }, keyModifiers.ctrl);
                    dx = precisionDelta.x;
                    dy = precisionDelta.y;

                    updatePolygon(draggedEye, polyDragOrigRef.current.map(p => ({ x: p.x + dx, y: p.y + dy })));
                    drawOverlay();
                    return;
                }

                if (draggedPointIndex !== null && draggedEye) {
                    let currentPoints;
                    // Use refs for current values instead of state
                    if (draggedEye === 'mouth') currentPoints = polyPointsRef.current;
                    else if (draggedEye === 'leftEye') currentPoints = leftEyePointsRef.current;
                    else if (draggedEye === 'rightEye') currentPoints = rightEyePointsRef.current;
                    else if (draggedEye === 'leftBrow') currentPoints = leftBrowPointsRef.current;
                    else if (draggedEye === 'rightBrow') currentPoints = rightBrowPointsRef.current;
                    else if (draggedEye === 'lipLine') currentPoints = lipLinePointsRef.current;

                    if (currentPoints) {
                        let newPos = m;

                        // Apply axis constraint (Shift key)
                        newPos = applyAxisConstraint(newPos, dragStartPos, keyModifiers.shift);

                        // Apply precision mode (Ctrl key)
                        if (keyModifiers.ctrl && dragStartPos) {
                            const dx = (newPos.x - dragStartPos.x) * 0.25;
                            const dy = (newPos.y - dragStartPos.y) * 0.25;
                            newPos = { x: dragStartPos.x + dx, y: dragStartPos.y + dy };
                        }

                        // Apply snap to grid (Alt key or snapToGrid enabled)
                        if (keyModifiers.alt || snapToGrid) {
                            newPos = snapPoint(newPos, gridSize);
                        }

                        const newPoints = [...currentPoints];
                        newPoints[draggedPointIndex] = newPos;
                        updatePolygon(draggedEye, newPoints);
                        drawOverlay();
                    }
                    return;
                }

                // Update cursor based on what's under the mouse and track hovered point
                let cursor = 'default';

                // Check for resize handle first
                const resizeHandle = findResizeHandle(m);
                if (resizeHandle) {
                    cursor = 'nwse-resize';
                    setHoveredPoint(null);
                    canvasRef.current.style.cursor = cursor;
                    return;
                }

                const clicked = findClickedPolygon(m);
                if (clicked) {
                    if (clicked.pointIndex !== -1) {
                        cursor = 'move';
                        setHoveredPoint({ type: clicked.type, index: clicked.pointIndex });
                    } else {
                        cursor = isDraggingPoly ? 'grabbing' : 'grab';
                        setHoveredPoint(null);
                    }
                } else {
                    setHoveredPoint(null);
                    // Check if near edge for adding points (increased radius for touch)
                    const edgeRadius = getHitRadius(22);
                    for (const {poly} of [
                        {poly: polyPointsRef.current},
                        {poly: lipLinePointsRef.current},
                        {poly: leftEyePointsRef.current},
                        {poly: rightEyePointsRef.current},
                        {poly: leftBrowPointsRef.current},
                        {poly: rightBrowPointsRef.current}
                    ]) {
                        for (let i = 0; i < poly.length; i++) {
                            const p1 = poly[i];
                            const p2 = poly[(i + 1) % poly.length];
                            if (distToSegment(m, p1, p2) < edgeRadius) cursor = 'copy';
                        }
                    }
                }
                canvasRef.current.style.cursor = cursor;
            };

            const handleMouseUp = () => {
                // Save to history if we were dragging or resizing
                if (draggedPointIndex !== null || draggedEye !== null || isDraggingPoly || isResizing) {
                    saveToHistory();
                }

                // Clear panning state
                setIsPanning(false);
                panStartRef.current = null;
                panOffsetStartRef.current = null;

                // Clear resize state
                setIsResizing(false);
                setResizingZone(null);
                resizeStartRef.current = null;

                setDraggedPointIndex(null);
                setDraggedEye(null);
                setIsDraggingPoly(false);
                setDragStartPos(null);
                polyDragStartRef.current = null;
                polyDragOrigRef.current = null;

                drawOverlay();
            };

            // Mouse wheel zoom handler
            const handleWheel = (e) => {
                if (!image || isAnimating) return;
                e.preventDefault();

                const rect = canvasRef.current.getBoundingClientRect();
                const scaleX = canvasRef.current.width / rect.width;
                const scaleY = canvasRef.current.height / rect.height;

                // Get mouse position in canvas coordinates
                const mouseX = (e.clientX - rect.left) * scaleX;
                const mouseY = (e.clientY - rect.top) * scaleY;

                // Convert to image space
                const imageWidth = canvasRef.current.width;
                const imageHeight = canvasRef.current.height;

                // Calculate zoom direction
                const zoomDelta = e.deltaY > 0 ? 0.9 : 1.1; // Scroll down = zoom out, scroll up = zoom in
                const newZoomScale = Math.max(1.0, Math.min(5.0, zoomScale * zoomDelta));

                if (newZoomScale === zoomScale) return;

                // Calculate new viewport size
                const newViewportWidth = imageWidth / newZoomScale;
                const newViewportHeight = imageHeight / newZoomScale;

                // Get mouse position in image space (before zoom)
                let imageMouseX, imageMouseY;
                if (zoomScale > 1.0) {
                    const viewportWidth = imageWidth / zoomScale;
                    const viewportHeight = imageHeight / zoomScale;
                    imageMouseX = (mouseX / imageWidth) * viewportWidth + panOffset.x;
                    imageMouseY = (mouseY / imageHeight) * viewportHeight + panOffset.y;
                } else {
                    imageMouseX = mouseX;
                    imageMouseY = mouseY;
                }

                // Calculate new pan offset to keep mouse position stable
                let newPanX = imageMouseX - (mouseX / imageWidth) * newViewportWidth;
                let newPanY = imageMouseY - (mouseY / imageHeight) * newViewportHeight;

                // Clamp pan offset
                newPanX = Math.max(0, Math.min(imageWidth - newViewportWidth, newPanX));
                newPanY = Math.max(0, Math.min(imageHeight - newViewportHeight, newPanY));

                if (newZoomScale <= 1.0) {
                    newPanX = 0;
                    newPanY = 0;
                }

                setZoomScale(newZoomScale);
                setIsZoomed(newZoomScale > 1.0);
                setPanOffset({ x: newPanX, y: newPanY });
                setTimeout(drawOverlay, 10);
            };

            const handleDoubleClick = (e) => {
                if(isAnimating || !image) return;
                const m = getCoords(e);

                // Check all polygons for point removal (uses zoom-adjusted radius via findClickedPolygon)
                const clicked = findClickedPolygon(m);
                if (clicked && clicked.pointIndex !== -1) {
                    if (clicked.points.length > 3) {
                        const filtered = clicked.points.filter((_, i) => i !== clicked.pointIndex);
                        updatePolygon(clicked.type, filtered);
                        saveToHistory();
                        drawOverlay();
                    }
                    return;
                }

                // Check all polygons for adding points on edges (zoom-adjusted radius)
                const edgeRadius = getHitRadius(22);
                for (const {type, points} of [
                    {type: 'mouth', points: polyPointsRef.current},
                    {type: 'lipLine', points: lipLinePointsRef.current},
                    {type: 'leftEye', points: leftEyePointsRef.current},
                    {type: 'rightEye', points: rightEyePointsRef.current},
                    {type: 'leftBrow', points: leftBrowPointsRef.current},
                    {type: 'rightBrow', points: rightBrowPointsRef.current}
                ]) {
                    for (let i = 0; i < points.length; i++) {
                        const p1 = points[i];
                        const p2 = points[(i + 1) % points.length];
                        if (distToSegment(m, p1, p2) < edgeRadius) {
                            const newPoints = [...points];
                            newPoints.splice(i + 1, 0, m);
                            updatePolygon(type, newPoints);
                            saveToHistory();
                            drawOverlay();
                            return;
                        }
                    }
                }
            };

            // Touch event handlers for mobile support with pinch-to-zoom
            const handleTouchStart = (e) => {
                // Don't prevent default if there's no image (allows upload zone to work)
                if (!image) return;
                e.preventDefault();

                // Check for pinch gesture (two fingers)
                if (e.touches.length === 2) {
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    const dist = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
                    lastPinchDistRef.current = dist;

                    // Store pinch center for zoom focus
                    const rect = canvasRef.current.getBoundingClientRect();
                    const scaleX = canvasRef.current.width / rect.width;
                    const scaleY = canvasRef.current.height / rect.height;
                    pinchCenterRef.current = {
                        x: ((touch1.clientX + touch2.clientX) / 2 - rect.left) * scaleX,
                        y: ((touch1.clientY + touch2.clientY) / 2 - rect.top) * scaleY
                    };
                    return;
                }

                // Single touch - handle as mouse down
                handleMouseDown(e);
            };

            const handleTouchMove = (e) => {
                if (!image) return;
                e.preventDefault();

                // Handle pinch-to-zoom (two fingers)
                if (e.touches.length === 2 && lastPinchDistRef.current !== null) {
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    const newDist = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
                    const pinchDelta = newDist / lastPinchDistRef.current;

                    if (Math.abs(pinchDelta - 1) > 0.01) { // Threshold to avoid jitter
                        const imageWidth = canvasRef.current.width;
                        const imageHeight = canvasRef.current.height;

                        const newZoomScale = Math.max(1.0, Math.min(5.0, zoomScale * pinchDelta));

                        if (newZoomScale !== zoomScale && pinchCenterRef.current) {
                            const newViewportWidth = imageWidth / newZoomScale;
                            const newViewportHeight = imageHeight / newZoomScale;

                            // Get pinch center in image space
                            let imageCenterX, imageCenterY;
                            if (zoomScale > 1.0) {
                                const viewportWidth = imageWidth / zoomScale;
                                const viewportHeight = imageHeight / zoomScale;
                                imageCenterX = (pinchCenterRef.current.x / imageWidth) * viewportWidth + panOffset.x;
                                imageCenterY = (pinchCenterRef.current.y / imageHeight) * viewportHeight + panOffset.y;
                            } else {
                                imageCenterX = pinchCenterRef.current.x;
                                imageCenterY = pinchCenterRef.current.y;
                            }

                            // Calculate new pan offset to keep pinch center stable
                            let newPanX = imageCenterX - (pinchCenterRef.current.x / imageWidth) * newViewportWidth;
                            let newPanY = imageCenterY - (pinchCenterRef.current.y / imageHeight) * newViewportHeight;

                            // Clamp pan offset
                            newPanX = Math.max(0, Math.min(imageWidth - newViewportWidth, newPanX));
                            newPanY = Math.max(0, Math.min(imageHeight - newViewportHeight, newPanY));

                            if (newZoomScale <= 1.0) {
                                newPanX = 0;
                                newPanY = 0;
                            }

                            setZoomScale(newZoomScale);
                            setIsZoomed(newZoomScale > 1.0);
                            setPanOffset({ x: newPanX, y: newPanY });
                        }

                        lastPinchDistRef.current = newDist;
                        drawOverlay();
                    }
                    return;
                }

                // Single touch - handle as mouse move
                handleMouseMove(e);
            };

            const handleTouchEnd = (e) => {
                if (!image) return;
                e.preventDefault();

                // Double-tap detection for mobile
                if (e.changedTouches && e.changedTouches.length === 1) {
                    const touch = e.changedTouches[0];
                    const now = Date.now();
                    const tapPos = { x: touch.clientX, y: touch.clientY };

                    if (lastTapRef.current) {
                        const timeDiff = now - lastTapRef.current.time;
                        const dx = tapPos.x - lastTapRef.current.x;
                        const dy = tapPos.y - lastTapRef.current.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        // Double-tap detected: within 300ms and 30px
                        if (timeDiff < 300 && distance < 30) {
                            lastTapRef.current = null; // Reset to avoid triple-tap
                            handleDoubleClick(e);
                            return;
                        }
                    }

                    // Store this tap for next time
                    lastTapRef.current = { x: tapPos.x, y: tapPos.y, time: now };
                }

                // Reset pinch state
                lastPinchDistRef.current = null;
                pinchCenterRef.current = null;

                handleMouseUp(e);
            };

            const toggleEyePreset = (preset) => {
                if (eyePresets.includes(preset)) {
                    setEyePresets(eyePresets.filter(p => p !== preset));
                } else {
                    setEyePresets([...eyePresets, preset]);
                }
            };

            // --- 3D DENTAL ENGINE ---
            const generateMouthTexture = (w, h) => {
                if(w<1 || h<1) return;
                const cvs = document.createElement('canvas'); cvs.width = w; cvs.height = h;
                const ctx = cvs.getContext('2d');
                const cx = w / 2; const cy = h * params.current.lipSplit; 

                // 1. THROAT (Depth Gradient)
                const throat = ctx.createRadialGradient(cx, cy, 0, cx, cy, w * 0.8);
                throat.addColorStop(0, '#0a0000'); 
                throat.addColorStop(0.5, '#200505'); 
                throat.addColorStop(1, '#3a1010'); 
                ctx.fillStyle = throat; ctx.fillRect(0, 0, w, h);

                // 2. TONGUE (High Rise)
                // Use the Tongue Height slider to determine top of tongue
                // Slider 0.0 = low (floor), 1.0 = high (roof)
                const tongueTop = h - (h * 0.8 * params.current.tongueHeight); 
                const tongueW = w * 0.55;
                
                const tongue = ctx.createRadialGradient(cx, h, 0, cx, h, tongueW);
                tongue.addColorStop(0, '#c04a4a'); // Pinkish Red
                tongue.addColorStop(0.8, '#5e1919'); // Dark sides
                ctx.fillStyle = tongue; 
                ctx.beginPath();
                // Draw tongue hump
                ctx.ellipse(cx, h + (h*0.1), tongueW, (h - tongueTop) + (h*0.1), 0, 0, Math.PI * 2);
                ctx.fill();
                // Tongue Center Crease
                ctx.strokeStyle = 'rgba(80,0,0,0.1)'; ctx.lineWidth = 4;
                ctx.beginPath(); ctx.moveTo(cx, tongueTop + 10); ctx.lineTo(cx, h); ctx.stroke();

                // 3. BOTTOM MOLARS (The Depth Illusion)
                // We draw faint, dark shapes on the sides of the jaw
                const molarY = h * 0.7; // Lower jaw line
                const molarW = w * 0.2;
                ctx.fillStyle = '#2a1a1a'; // Dark tooth color
                // Left Molar
                ctx.beginPath(); ctx.ellipse(cx - w*0.35, molarY, molarW, h*0.1, 0, 0, Math.PI*2); ctx.fill();
                // Right Molar
                ctx.beginPath(); ctx.ellipse(cx + w*0.35, molarY, molarW, h*0.1, 0, 0, Math.PI*2); ctx.fill();
                // Add shading to push them back
                const shadowOverlay = ctx.createLinearGradient(0,0,0,h);
                shadowOverlay.addColorStop(0, 'rgba(0,0,0,0.5)'); 
                shadowOverlay.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = shadowOverlay; ctx.fillRect(0,0,w,h);

                // 4. TOP TEETH (3D Enamel Shader)
                const bright = Math.floor(255 * params.current.teethBrightness);
                // Calculate tint based on Shade slider (0=White, 1=Yellow)
                const shade = params.current.teethShade;
                const r = bright;
                const g = Math.floor(bright * (1 - (shade * 0.1))); // Less Green = Redder
                const b = Math.floor(bright * (1 - (shade * 0.3))); // Less Blue = Yellower
                
                const toothBase = `rgb(${r},${g},${b})`;
                const toothShadow = `rgb(${r-60},${g-60},${b-70})`;
                const toothTip = `rgba(${r+20},${g+20},${b+40},0.6)`; // Bluish translucent tip

                const teethOffset = h * params.current.teethVertical; 
                const jawGap = h * (0.3 - params.current.jawGap);
                const teethY = cy - jawGap + teethOffset; 
                
                const teethH = h * 0.18; 
                const teethW = w * 0.7 * params.current.lipWidth; // Match width to lips
                
                // Gum Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.4)'; ctx.beginPath(); 
                ctx.ellipse(cx, teethY - teethH, teethW/2, teethH/2, 0, 0, Math.PI*2); ctx.fill();

                const toothCount = 6; const startX = cx - (teethW / 2); const totalW = teethW;
                
                // Shadow Blur for "No Outlines" look
                ctx.shadowColor = "rgba(0,0,0,0.4)";
                ctx.shadowBlur = 4;

                for(let i=0; i<toothCount; i++) {
                    let relW = 1; if (i === 0 || i === 5) relW = 0.85; if (i === 1 || i === 4) relW = 0.85; if (i === 2 || i === 3) relW = 1.1; 
                    const unitW = totalW / 5.7; const tW = unitW * relW;
                    let tX = startX;
                    if(i>0) tX += (unitW * 0.85); if(i>1) tX += (unitW * 0.85); if(i>2) tX += (unitW * 1.1); if(i>3) tX += (unitW * 1.1); if(i>4) tX += (unitW * 0.85);
                    
                    const dist = Math.abs(i - 2.5); const curveY = dist * (h * 0.015);
                    const tTop = teethY - teethH - curveY; const tBot = teethY - curveY;
                    
                    // 3D Gradient
                    const grad = ctx.createLinearGradient(tX, tTop, tX, tBot);
                    grad.addColorStop(0, toothShadow); // Root
                    grad.addColorStop(0.3, toothBase); // Body
                    grad.addColorStop(0.8, toothBase); 
                    grad.addColorStop(1, toothTip); // Enamel Tip
                    ctx.fillStyle = grad; 
                    
                    ctx.beginPath(); 
                    // Round Top
                    ctx.moveTo(tX + 2, tBot); 
                    ctx.lineTo(tX + 1, tTop + 5);
                    ctx.quadraticCurveTo(tX + tW/2, tTop - 2, tX + tW - 1, tTop + 5);
                    // Square Bottom
                    ctx.lineTo(tX + tW - 2, tBot); 
                    ctx.lineTo(tX + 2, tBot); 
                    ctx.fill();
                    
                    // Specular Highlight (The "Wet" Look)
                    ctx.shadowBlur = 0; // Turn off shadow for highlight
                    ctx.fillStyle = 'rgba(255,255,255,0.3)';
                    ctx.beginPath();
                    ctx.ellipse(tX + tW*0.3, tTop + teethH*0.4, tW*0.2, teethH*0.15, 0, 0, Math.PI*2);
                    ctx.fill();
                    ctx.shadowBlur = 4; // Turn back on
                }
                ctx.shadowBlur = 0; // Reset
                mouthTextureRef.current = ctx.getImageData(0, 0, w, h).data;
            };

            const processFrame = (openAmount, ctx, bounds, mouthBuffer, maskData) => {
                if (!originalImageDataRef.current) return;
                if (!mouthTextureRef.current) {
                    console.error('Mouth texture not generated!');
                    return;
                }

                const currentImg = ctx.getImageData(bounds.x, bounds.y, bounds.width, bounds.height);
                const dst = currentImg.data;
                const innerMouth = mouthTextureRef.current;

                const w = bounds.width; const h = bounds.height;
                const cx = w / 2;
                const activeWidthRatio = params.current.lipWidth;
                const baseSplitY = h * params.current.lipSplit;

                // Edge blend factor (20% of region from edge fades to zero movement)
                const edgeBlendX = w * 0.2;
                const edgeBlendY = h * 0.2;
                const smooth01 = (t) => { t = Math.max(0, Math.min(1, t)); return t * t * (3 - 2 * t); };

                const rollPx = Math.max(0, Math.floor((params.current.lipRoll || 0) * 12));
                const rollStrength = (params.current.lipRoll || 0);

                const splitTex = (params.current.splitTexture || 0);
                const splitCol = (params.current.splitColor || 0);

                for (let x = 0; x < w; x++) {
                    const nx = (x - cx) / (w * activeWidthRatio / 2);

                    // Calculate edge blend factor for this x position (0 at edge, 1 in center)
                    let blendFactorX = 1;
                    if (x < edgeBlendX) {
                        blendFactorX = x / edgeBlendX;
                    } else if (x > w - edgeBlendX) {
                        blendFactorX = (w - x) / edgeBlendX;
                    }

                    // Wave Logic
                    const mainCurve = (nx * nx) * params.current.lipCurve * (h * 0.1);
                    const bow = Math.cos(nx * Math.PI * 2.5) * params.current.cupidBow * (h * 0.05);
                    const bowFaded = bow * Math.max(0, 1 - Math.abs(nx * 1.5));
                    const localSplitY = baseSplitY - mainCurve - bowFaded;

                    const curve = (Math.abs(nx) >= 1) ? 0 : Math.cos(nx * (Math.PI / 2));
                    const baseShift = Math.floor(openAmount * curve);

                    if (baseShift > 0) {
                        let topLipY = Math.floor(localSplitY - (baseShift * 0.3));
                        let bottomLipY = Math.floor(localSplitY + (baseShift * 0.7));

                        // Jaw Gap: higher slider value = teeth closer (shrink interior opening)
                        const jawClose01 = Math.min(1, Math.max(0, (params.current.jawGap || 0) / 0.3));
                        const jawClosePx = Math.round(jawClose01 * (h * 0.06 + 6));
                        topLipY += jawClosePx;
                        bottomLipY -= jawClosePx;

                        // Consonant articulation press (strongest at center)
                        const art = params.current.articulation || 0;
                        const snap = params.current.syllableSnap || 0;
                        const centerW = Math.max(0, 1 - Math.abs(nx));
                        const pressPx = Math.round(art * centerW * (2 + 10 * snap));
                        topLipY += pressPx;
                        bottomLipY -= pressPx;

                        if (bottomLipY <= topLipY + 2) bottomLipY = topLipY + 2;

                        for (let y = 0; y < h; y++) {
                            const idx = (y * w + x) * 4;
                            if (maskData[idx + 3] === 0) continue;

                            // Calculate edge blend factor for this y position (0 at edge, 1 in center)
                            let blendFactorY = 1;
                            if (y < edgeBlendY) {
                                blendFactorY = y / edgeBlendY;
                            } else if (y > h - edgeBlendY) {
                                blendFactorY = (h - y) / edgeBlendY;
                            }

                            // Combined edge blend factor with smoothstep
                            const blendFactor = blendFactorX * blendFactorY;
                            const smoothBlend = smooth01(blendFactor);

                            // Apply edge-blended shift
                            const shift = baseShift * smoothBlend;

                            // Mouth interior
                            if (y > topLipY && y < bottomLipY) {
                                if (innerMouth[idx + 3] > 0) {
                                    dst[idx] = innerMouth[idx];
                                    dst[idx + 1] = innerMouth[idx + 1];
                                    dst[idx + 2] = innerMouth[idx + 2];
                                    dst[idx + 3] = 255;
                                }
                                continue;
                            }

                            // Lips / surrounding (warped sampling)
                            let srcY = y; let isLipEdge = false;

                            if (y <= topLipY) {
                                srcY = y + (shift * 0.3);
                                if (srcY >= localSplitY - 3) isLipEdge = true;
                            } else if (y >= bottomLipY) {
                                const distFromChin = (y - bottomLipY);
                                const jawFalloff = Math.max(0, 1 - (distFromChin / (h * 0.6)));
                                srcY = y - (shift * 0.7 * 1.3 * jawFalloff);
                                if (srcY <= localSplitY + 3) isLipEdge = true;
                            }

                            // Pin a thin band around the split so the wet line doesn't wobble
                            const clampBand = 1 + Math.round(splitTex * 2);
                            if (isLipEdge && Math.abs(y - localSplitY) <= clampBand) srcY = y;

                            // Sub-pixel sampling (linear interp) to remove 1px jitter
                            if (srcY >= 0 && srcY < h - 1) {
                                const y0 = Math.floor(srcY);
                                const t = srcY - y0;

                                const i0 = (y0 * w + x) * 4;
                                const i1 = ((y0 + 1) * w + x) * 4;

                                const a0 = mouthBuffer[i0 + 3], a1 = mouthBuffer[i1 + 3];
                                const a = a0 * (1 - t) + a1 * t;
                                if (a <= 20) continue;

                                let r = Math.round(mouthBuffer[i0] * (1 - t) + mouthBuffer[i1] * t);
                                let g = Math.round(mouthBuffer[i0 + 1] * (1 - t) + mouthBuffer[i1 + 1] * t);
                                let b = Math.round(mouthBuffer[i0 + 2] * (1 - t) + mouthBuffer[i1 + 2] * t);

                                // --- Lip Roll: wrap texture into the inner edge near the split ---
                                if (rollPx > 0 && isLipEdge && openAmount > 2) {
                                    const edgeDist = Math.abs(srcY - localSplitY);
                                    if (edgeDist <= rollPx) {
                                        const tt = rollStrength * (1 - edgeDist / (rollPx + 1e-9));
                                        const dir = (srcY < localSplitY) ? -1 : 1;
                                        const rollSrcY = Math.round(srcY + dir * rollPx);

                                        if (rollSrcY >= 0 && rollSrcY < h) {
                                            const rollIdx = (rollSrcY * w + x) * 4;
                                            if (mouthBuffer[rollIdx + 3] > 20) {
                                                const rr = mouthBuffer[rollIdx];
                                                const gg = mouthBuffer[rollIdx + 1];
                                                const bb = mouthBuffer[rollIdx + 2];

                                                const shade = 1 - (tt * 0.12);
                                                r = Math.round((r * (1 - tt) + rr * tt) * shade);
                                                g = Math.round((g * (1 - tt) + gg * tt) * shade);
                                                b = Math.round((b * (1 - tt) + bb * tt) * shade);
                                            }
                                        }
                                    }
                                }

                                if (isLipEdge && openAmount > 2) {
                                    // Lip brighten (existing)
                                    const boost = params.current.lipLighten * 60;

                                    // Split Color tint (pinned to the split)
                                    const edge = Math.max(0, 1 - (Math.abs(y - localSplitY) / 3));
                                    const tcol = splitCol * edge;
                                    r = Math.min(255, Math.max(0, r + 40 * tcol));
                                    g = Math.min(255, Math.max(0, g - 10 * tcol));
                                    b = Math.min(255, Math.max(0, b - 18 * tcol));

                                    // Split Texture: micro-contrast + wet line (pinned to the split)
                                    if (splitTex > 0) {
                                        const dir = (y < localSplitY) ? -1 : 1;

                                        const yA = Math.max(0, Math.min(h - 1, y + dir * 1));
                                        const yB = Math.max(0, Math.min(h - 1, y - dir * 1));

                                        const aIdx = (yA * w + x) * 4;
                                        const bIdx = (yB * w + x) * 4;

                                        const la = (mouthBuffer[aIdx] * 0.299 + mouthBuffer[aIdx + 1] * 0.587 + mouthBuffer[aIdx + 2] * 0.114);
                                        const lb = (mouthBuffer[bIdx] * 0.299 + mouthBuffer[bIdx + 1] * 0.587 + mouthBuffer[bIdx + 2] * 0.114);

                                        const contrast = (la - lb) / 255;
                                        const k = splitTex * 0.35;

                                        r = Math.min(255, Math.max(0, r + contrast * 60 * k));
                                        g = Math.min(255, Math.max(0, g + contrast * 45 * k));
                                        b = Math.min(255, Math.max(0, b + contrast * 35 * k));

                                        const edgeDistY = Math.abs(y - localSplitY);
                                        const spec = Math.max(0, 1 - edgeDistY / 1.6) * splitTex * 22;

                                        r = Math.min(255, r + spec);
                                        g = Math.min(255, g + spec * 0.9);
                                        b = Math.min(255, b + spec * 0.8);
                                    }

                                    r = Math.min(255, r + boost);
                                    g = Math.min(255, g + boost);
                                    b = Math.min(255, b + boost);
                                }

                                dst[idx] = r;
                                dst[idx + 1] = g;
                                dst[idx + 2] = b;
                                dst[idx + 3] = 255;
                            }
                        }
                    }
                }

                ctx.putImageData(currentImg, bounds.x, bounds.y);
            };

            const rgbToHsl = (r, g, b) => {
                r /= 255; g /= 255; b /= 255;
                const max = Math.max(r, g, b), min = Math.min(r, g, b);
                let h, s, l = (max + min) / 2;
                if (max === min) {
                    h = s = 0;
                } else {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    switch (max) {
                        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                        case g: h = (b - r) / d + 2; break;
                        case b: h = (r - g) / d + 4; break;
                    }
                    h /= 6;
                }
                return [h, s, l];
            };

            const hslToRgb = (h, s, l) => {
                let r, g, b;
                if (s === 0) {
                    r = g = b = l;
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    };
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }
                return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
            };

            const processEyeFrame = (eyeOpen, ctx, bounds, eyeBuffer, maskData, currentPupilX, currentPupilY) => {
                if (!originalImageDataRef.current || bounds.width < 1 || bounds.height < 1) return;

                const currentImg = ctx.getImageData(bounds.x, bounds.y, bounds.width, bounds.height);
                const dst = currentImg.data;

                const w = bounds.width; const h = bounds.height;
                const cx = w / 2; const cy = h / 2;
                const baseSplitY = h * 0.5; // Eyes split horizontally

                // For eyes, we warp the upper lid down for closing or up for widening
                let maxClose = h * 0.4;
                let closeAmount = (1 - eyeOpen) * maxClose; // Negative for wide open (excited)

                // Calculate pixel shift for eye gaze (shift the actual eyeball pixels)
                const maxGazeShiftX = w * 0.15; // Max horizontal shift
                const maxGazeShiftY = h * 0.12; // Max vertical shift
                const gazeShiftX = currentPupilX * maxGazeShiftX;
                const gazeShiftY = currentPupilY * maxGazeShiftY;

                // Edge blend factor (20% of region from edge)
                const edgeBlendX = w * 0.2;
                const edgeBlendY = h * 0.2;

                for (let x = 0; x < w; x++) {
                    const nx = (x - cx) / (w / 2);
                    const curve = Math.cos(nx * (Math.PI / 2));

                    const lidShift = Math.floor(closeAmount * curve);

                    // Calculate edge blend factor for this x position (0 at edge, 1 in center)
                    let blendFactorX = 1;
                    if (x < edgeBlendX) {
                        blendFactorX = x / edgeBlendX;
                    } else if (x > w - edgeBlendX) {
                        blendFactorX = (w - x) / edgeBlendX;
                    }

                    for (let y = 0; y < h; y++) {
                        const idx = (y * w + x) * 4;
                        if (maskData[idx + 3] === 0) continue;

                        // Calculate edge blend factor for this y position
                        let blendFactorY = 1;
                        if (y < edgeBlendY) {
                            blendFactorY = y / edgeBlendY;
                        } else if (y > h - edgeBlendY) {
                            blendFactorY = (h - y) / edgeBlendY;
                        }

                        // Combined edge blend factor (smoothstep for smoother falloff)
                        const blendFactor = blendFactorX * blendFactorY;
                        const smoothBlend = blendFactor * blendFactor * (3 - 2 * blendFactor); // Smoothstep

                        let srcY = y;
                        let srcX = x;

                        // Apply lid movement
                        if (y < baseSplitY) {
                            // Upper lid moves down for close, up for wide
                            srcY = y - lidShift * smoothBlend;
                        } else {
                            // Lower lid movement
                            if (closeAmount > 0) {
                                // Closing: lower lid moves up
                                srcY = y + (lidShift * 0.3 * smoothBlend);
                            } else if (closeAmount < 0) {
                                // Excited/wide: lower lid moves down
                                srcY = y + (lidShift * 0.6 * smoothBlend);
                            }
                        }

                        // Apply gaze shift (shift the actual eye pixels) with edge blending
                        srcX = x - gazeShiftX * smoothBlend;
                        srcY = srcY - gazeShiftY * smoothBlend;

                        // Clamp source coordinates
                        srcX = Math.max(0, Math.min(w - 1, srcX));
                        srcY = Math.max(0, Math.min(h - 1, srcY));

                        // Bilinear interpolation for smooth sampling
                        const x0 = Math.floor(srcX);
                        const y0 = Math.floor(srcY);
                        const x1 = Math.min(x0 + 1, w - 1);
                        const y1 = Math.min(y0 + 1, h - 1);
                        const tx = srcX - x0;
                        const ty = srcY - y0;

                        const i00 = (y0 * w + x0) * 4;
                        const i10 = (y0 * w + x1) * 4;
                        const i01 = (y1 * w + x0) * 4;
                        const i11 = (y1 * w + x1) * 4;

                        // Bilinear interpolation
                        const r = Math.round(
                            eyeBuffer[i00] * (1 - tx) * (1 - ty) +
                            eyeBuffer[i10] * tx * (1 - ty) +
                            eyeBuffer[i01] * (1 - tx) * ty +
                            eyeBuffer[i11] * tx * ty
                        );
                        const g = Math.round(
                            eyeBuffer[i00 + 1] * (1 - tx) * (1 - ty) +
                            eyeBuffer[i10 + 1] * tx * (1 - ty) +
                            eyeBuffer[i01 + 1] * (1 - tx) * ty +
                            eyeBuffer[i11 + 1] * tx * ty
                        );
                        const b = Math.round(
                            eyeBuffer[i00 + 2] * (1 - tx) * (1 - ty) +
                            eyeBuffer[i10 + 2] * tx * (1 - ty) +
                            eyeBuffer[i01 + 2] * (1 - tx) * ty +
                            eyeBuffer[i11 + 2] * tx * ty
                        );

                        dst[idx] = r;
                        dst[idx + 1] = g;
                        dst[idx + 2] = b;
                        dst[idx + 3] = 255;
                    }
                }

                ctx.putImageData(currentImg, bounds.x, bounds.y);
            };


            const startAnimation = async () => {
                if (polyPoints.length < 3) {
                    setStatus("Please detect or draw mouth points first!");
                    return;
                }

                setStatus("Starting animation...");
                const bounds = getBounds(polyPoints);

                // Generate mouth texture before starting
                if (bounds.width > 0 && bounds.height > 0) {
                    generateMouthTexture(bounds.width, bounds.height);
                    console.log('Generated mouth texture:', bounds.width, 'x', bounds.height);
                } else {
                    setStatus("Invalid mouth bounds!");
                    return;
                }

                const leftEyeBounds = getBounds(leftEyePoints);
                const rightEyeBounds = getBounds(rightEyePoints);
                const ctx = canvasRef.current.getContext('2d');
                
                const maskCvs = document.createElement('canvas');
                maskCvs.width = bounds.width; maskCvs.height = bounds.height;
                const mCtx = maskCvs.getContext('2d');
                mCtx.beginPath();
                mCtx.moveTo(polyPoints[0].x - bounds.x, polyPoints[0].y - bounds.y);
                for(let i=1; i<polyPoints.length; i++) mCtx.lineTo(polyPoints[i].x - bounds.x, polyPoints[i].y - bounds.y);
                mCtx.closePath();
                mCtx.fillStyle = '#000000'; mCtx.fill();
                const maskData = mCtx.getImageData(0,0,bounds.width,bounds.height).data;

                // Eye masks
                const leftMaskCvs = document.createElement('canvas');
                leftMaskCvs.width = leftEyeBounds.width; leftMaskCvs.height = leftEyeBounds.height;
                const lCtx = leftMaskCvs.getContext('2d');
                lCtx.beginPath();
                if (leftEyePoints.length > 0) {
                    lCtx.moveTo(leftEyePoints[0].x - leftEyeBounds.x, leftEyePoints[0].y - leftEyeBounds.y);
                    for (let i = 1; i < leftEyePoints.length; i++) lCtx.lineTo(leftEyePoints[i].x - leftEyeBounds.x, leftEyePoints[i].y - leftEyeBounds.y);
                    lCtx.closePath();
                    lCtx.fill();
                }
                const leftMaskData = lCtx.getImageData(0, 0, leftEyeBounds.width, leftEyeBounds.height).data;

                const rightMaskCvs = document.createElement('canvas');
                rightMaskCvs.width = rightEyeBounds.width; rightMaskCvs.height = rightEyeBounds.height;
                const rCtx = rightMaskCvs.getContext('2d');
                rCtx.beginPath();
                if (rightEyePoints.length > 0) {
                    rCtx.moveTo(rightEyePoints[0].x - rightEyeBounds.x, rightEyePoints[0].y - rightEyeBounds.y);
                    for (let i = 1; i < rightEyePoints.length; i++) rCtx.lineTo(rightEyePoints[i].x - rightEyeBounds.x, rightEyePoints[i].y - rightEyeBounds.y);
                    rCtx.closePath();
                    rCtx.fill();
                }
                const rightMaskData = rCtx.getImageData(0, 0, rightEyeBounds.width, rightEyeBounds.height).data;

                ctx.putImageData(originalImageDataRef.current, 0, 0);
                const fullData = ctx.getImageData(0, 0, canvasRef.current.width, canvasRef.current.height);
                const mouthBuffer = new Uint8ClampedArray(bounds.width * bounds.height * 4);
                
                for(let y=0; y<bounds.height; y++) {
                    for(let x=0; x<bounds.width; x++) {
                        const s = ((bounds.y+y)*canvasRef.current.width + (bounds.x+x))*4;
                        const d = (y*bounds.width+x)*4;
                        if(s < fullData.data.length && d < mouthBuffer.length) {
                            mouthBuffer.set(fullData.data.subarray(s, s+4), d);
                        }
                    }
                }

                // Eye buffers
                const leftEyeBuffer = new Uint8ClampedArray(leftEyeBounds.width * leftEyeBounds.height * 4);
                for (let y = 0; y < leftEyeBounds.height; y++) {
                    for (let x = 0; x < leftEyeBounds.width; x++) {
                        const s = ((leftEyeBounds.y + y) * canvasRef.current.width + (leftEyeBounds.x + x)) * 4;
                        const d = (y * leftEyeBounds.width + x) * 4;
                        if (s < fullData.data.length && d < leftEyeBuffer.length) {
                            leftEyeBuffer.set(fullData.data.subarray(s, s + 4), d);
                        }
                    }
                }

                const rightEyeBuffer = new Uint8ClampedArray(rightEyeBounds.width * rightEyeBounds.height * 4);
                for (let y = 0; y < rightEyeBounds.height; y++) {
                    for (let x = 0; x < rightEyeBounds.width; x++) {
                        const s = ((rightEyeBounds.y + y) * canvasRef.current.width + (rightEyeBounds.x + x)) * 4;
                        const d = (y * rightEyeBounds.width + x) * 4;
                        if (s < fullData.data.length && d < rightEyeBuffer.length) {
                            rightEyeBuffer.set(fullData.data.subarray(s, s + 4), d);
                        }
                    }
                }

                let audioCtx = audioContextRef.current;
                if (!audioCtx || audioCtx.state === 'closed') {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    audioContextRef.current = audioCtx;
                }
                if (audioCtx.state === 'suspended') await audioCtx.resume();

                setIsAnimating(true); setRecordedVideo(null);
                const stream = canvasRef.current.captureStream(60);
                chunksRef.current = []; let analyser;

                // Determine which audio source to use
                const useAudio = exportWithAudio && audioSource !== 'none';
                const useFileAudio = (audioSource === 'file' || audioSource === 'record') && audioUrl;
                const useVideoAudio = audioSource === 'video' && backgroundType === 'video' && backgroundVideoRef.current;
                const useTTS = audioSource === 'tts';

                if (useFileAudio) {
                    const audio = new Audio(audioUrl);
                    audio.crossOrigin = "anonymous";
                    audioRef.current = audio;
                    analyser = audioCtx.createAnalyser();
                    analyser.fftSize = 2048; analyser.smoothingTimeConstant = 0.5;
                    const src = audioCtx.createMediaElementSource(audio);
                    const dest = audioCtx.createMediaStreamDestination();
                    src.connect(analyser); src.connect(audioCtx.destination); src.connect(dest);
                    if (exportWithAudio) {
                        dest.stream.getAudioTracks().forEach(t => stream.addTrack(t));
                    }
                    audio.onended = stopEverything;
                    try { await audio.play(); } catch(e) { setStatus("Autoplay blocked. Click Stop."); console.warn(e); }
                } else if (useVideoAudio) {
                    // Use background video as audio source
                    const video = backgroundVideoRef.current;
                    video.currentTime = 0;
                    video.muted = false;
                    audioRef.current = video;
                    analyser = audioCtx.createAnalyser();
                    analyser.fftSize = 2048; analyser.smoothingTimeConstant = 0.5;
                    const src = audioCtx.createMediaElementSource(video);
                    const dest = audioCtx.createMediaStreamDestination();
                    src.connect(analyser); src.connect(audioCtx.destination); src.connect(dest);
                    if (exportWithAudio) {
                        dest.stream.getAudioTracks().forEach(t => stream.addTrack(t));
                    }
                    video.onended = stopEverything;
                    try { await video.play(); } catch(e) { setStatus("Autoplay blocked. Click Stop."); console.warn(e); }
                }

                try {
                    const recorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9', videoBitsPerSecond: 8000000 });
                    recorder.ondataavailable = e => { if (e.data.size > 0) chunksRef.current.push(e.data); };
                    recorder.onstop = () => setRecordedVideo(URL.createObjectURL(new Blob(chunksRef.current, {type:'video/webm'})));
                    recorder.start();
                    mediaRecorderRef.current = recorder;
                } catch (e) { console.warn(e); }

                const dataArray = new Uint8Array(analyser ? analyser.frequencyBinCount : 0);
                const timeArray = new Uint8Array(analyser ? analyser.fftSize : 0);

                const sr = audioCtx.sampleRate;
                const hzPerBin = analyser ? (sr / analyser.fftSize) : (sr / 2048);
                const bin = (hz) => {
                    if (!dataArray.length) return 0;
                    return Math.max(0, Math.min(dataArray.length - 1, Math.round(hz / hzPerBin)));
                };

                const pLo = bin(60),   pHi = bin(200);
                const vLo = bin(180),  vHi = bin(900);
                const cLo = bin(2000), cHi = bin(4500);

                const bandAvg = (arr, lo, hi) => {
                    if (!arr.length) return 0;
                    lo = Math.max(0, Math.min(arr.length - 1, lo));
                    hi = Math.max(0, Math.min(arr.length - 1, hi));
                    if (hi < lo) { const t = lo; lo = hi; hi = t; }
                    let s = 0, c = 0;
                    for (let i = lo; i <= hi; i++) { s += arr[i]; c++; }
                    return c ? (s / c) : 0;
                };

                const startTime = Date.now();
                let currentOpenness = 0;
                let prevTarget = 0;
                let plosiveHold = 0;
                let plosivePrev = 0;
                let eyeStateTimer = 0;
                let currentEyeState = 'normal';
                let currentPupilX = 0;
                let currentPupilY = 0;
                let eyeStateDuration = 0; // How long to hold current eye state

                let frameCount = 0;
                const loop = () => {
                    frameCount++;
                    if (frameCount === 1) {
                        console.log('Animation loop started!');
                        setStatus("Animating...");
                    }

                    const elapsed = (Date.now() - startTime) / 1000;

                    let target = 0;
                    let plos = 0, cons = 0, vowel = 0;

                    if (analyser) {
                        if (frameCount === 1) console.log('Using audio analysis mode');
                        analyser.getByteTimeDomainData(timeArray);
                        let rms = 0;
                        for (let i = 0; i < timeArray.length; i++) {
                            const v = (timeArray[i] - 128) / 128;
                            rms += v * v;
                        }
                        rms = timeArray.length ? Math.sqrt(rms / timeArray.length) : 0;

                        analyser.getByteFrequencyData(dataArray);
                        plos = bandAvg(dataArray, pLo, pHi) / 255;
                        vowel = bandAvg(dataArray, vLo, vHi) / 255;
                        cons = bandAvg(dataArray, cLo, cHi) / 255;

                        target = (rms * 1.3 + vowel * 0.9 + cons * 0.8 + plos * 0.6) / (1.3 + 0.9 + 0.8 + 0.6);
                        target = Math.min(1, Math.max(0, target));
                    } else if (useTTS) {
                        if (frameCount === 1) console.log('Using TTS mode');
                        const t = elapsed;
                        target = Math.abs(Math.sin(t * 8) * 0.5 + Math.sin(t * 19) * 0.4);

                        // pseudo consonant/plosive from transients
                        plos = Math.min(1, Math.max(0, (target - prevTarget) * 3));
                        cons = Math.min(1, Math.max(0, Math.abs(Math.cos(t * 12)) * 0.35));
                    } else {
                        // No audio mode or audio not playing - use fallback animation
                        if (frameCount === 1) console.log('Using fallback animation (no audio)');
                        const t = elapsed;
                        target = Math.abs(Math.sin(t * 8) * 0.5 + Math.sin(t * 19) * 0.4);
                        plos = Math.min(1, Math.max(0, (target - prevTarget) * 3));
                        cons = Math.min(1, Math.max(0, Math.abs(Math.cos(t * 12)) * 0.35));
                    }

                    const snap = params.current.syllableSnap || 0;

                    // Plosive closure snap (P/B/M/F/V)
                    const rise = plos - plosivePrev;
                    if (plos > (0.20 - 0.05 * snap) && rise > (0.06 - 0.03 * snap)) {
                        plosiveHold = 1;
                    }
                    plosivePrev = plos;

                    plosiveHold = Math.max(0, plosiveHold - (0.18 + 0.10 * snap));
                    const closure = (0.45 + 0.35 * snap) * plosiveHold;
                    target = Math.max(0, target * (1 - closure));

                    // Sensitivity
                    target *= params.current.sensitivity;

                    // Articulation scalar for lip press
                    params.current.articulation = Math.min(1, (cons * 0.9 + plos * 1.1)) * (0.35 + 0.65 * snap);

                    // Syllable Snap shaping + attack/release
                    let tVal = Math.max(0, target);
                    tVal = Math.pow(tVal, 1 - 0.75 * snap);

                    const gate = 0.05 + 0.10 * snap;
                    tVal = Math.max(0, (tVal - gate) / (1 - gate));

                    const delta = tVal - prevTarget;
                    if (delta > 0) tVal = Math.min(1, tVal + delta * (0.9 + 1.2 * snap));

                    const base = params.current.smoothing;
                    const attack = Math.min(1, base + 0.35 * snap);
                    const release = Math.max(0.02, base * (1 - 0.55 * snap));
                    const alpha = (tVal > currentOpenness) ? attack : release;

                    currentOpenness += (tVal - currentOpenness) * alpha;
                    prevTarget = tVal;

                    const maxOpen = bounds.height * 0.45;
                    const openPixels = Math.floor(currentOpenness * maxOpen);

                    if (frameCount === 1 || frameCount % 60 === 0) {
                        console.log('Frame', frameCount, '- target:', target.toFixed(3), 'currentOpenness:', currentOpenness.toFixed(3), 'openPixels:', openPixels, 'bounds:', bounds.width + 'x' + bounds.height);
                    }

                    // Process mouth animation
                    processFrame(openPixels, ctx, bounds, mouthBuffer, maskData);

                    // Eye animation
                    eyeStateTimer += 1 / 60;
                        let leftEyeOpen = 1;
                        let rightEyeOpen = 1;

                        // Check if it's time to change eye state
                        if (eyeStateTimer >= eyeStateDuration) {
                        eyeStateTimer = 0;
                        // Randomly pick a preset from the selected list, or stay normal
                        if (eyePresets.length > 0 && Math.random() < 0.3) {
                            const randomIndex = Math.floor(Math.random() * eyePresets.length);
                            currentEyeState = eyePresets[randomIndex];

                            // Set pupil position based on state
                            if (currentEyeState === 'look_left') { currentPupilX = -0.7; currentPupilY = 0; }
                            else if (currentEyeState === 'look_right') { currentPupilX = 0.7; currentPupilY = 0; }
                            else if (currentEyeState === 'look_up') { currentPupilX = 0; currentPupilY = -0.7; }
                            else if (currentEyeState === 'look_down') { currentPupilX = 0; currentPupilY = 0.7; }
                            else if (currentEyeState === 'eye_roll') {
                                // Eye roll will be animated in real-time below, just set initial position
                                currentPupilX = 0;
                                currentPupilY = -0.7; // Start looking up
                            }
                            else { currentPupilX = 0; currentPupilY = 0; }

                            // Duration depends on action type
                            if (currentEyeState === 'blink') eyeStateDuration = 0.15; // Quick blink
                            else if (currentEyeState === 'wink_left' || currentEyeState === 'wink_right') eyeStateDuration = 0.4; // Wink
                            else if (currentEyeState === 'excited') eyeStateDuration = 1.0 + Math.random() * 1.5; // Excited
                            else if (currentEyeState === 'glare') eyeStateDuration = 0.6 + Math.random() * 1.0; // Glare
                            else if (currentEyeState === 'eye_roll') eyeStateDuration = 1.5; // Complete roll cycle
                            else eyeStateDuration = 0.8 + Math.random() * 1.5; // Look around
                        } else {
                            currentEyeState = 'normal';
                            currentPupilX = 0;
                            currentPupilY = 0;
                            eyeStateDuration = 1.0 + Math.random() * 2.0; // Stay normal for a bit
                        }
                    }

                    // Animate eye_roll in real-time
                    if (currentEyeState === 'eye_roll') {
                        // Circular motion: progress through the roll
                        const rollProgress = eyeStateTimer / eyeStateDuration;
                        const angle = rollProgress * Math.PI * 2; // Full circle
                        currentPupilX = Math.sin(angle) * 0.7;
                        currentPupilY = -Math.cos(angle) * 0.7; // Start at top (negative Y)
                    }

                    // Set eye openness based on state (separate for left/right)
                    if (currentEyeState === 'blink') {
                        leftEyeOpen = 0;
                        rightEyeOpen = 0;
                    } else if (currentEyeState === 'wink_left') {
                        leftEyeOpen = 0;
                        rightEyeOpen = 1;
                    } else if (currentEyeState === 'wink_right') {
                        leftEyeOpen = 1;
                        rightEyeOpen = 0;
                    } else if (currentEyeState === 'glare') {
                        leftEyeOpen = 0.4;
                        rightEyeOpen = 0.4;
                    } else if (currentEyeState === 'excited') {
                        leftEyeOpen = 1.5; // Extra wide
                        rightEyeOpen = 1.5;
                    } else {
                        leftEyeOpen = 1;
                        rightEyeOpen = 1;
                    }

                        if (leftEyePoints.length > 2) processEyeFrame(leftEyeOpen, ctx, leftEyeBounds, leftEyeBuffer, leftMaskData, currentPupilX, currentPupilY);
                        if (rightEyePoints.length > 2) processEyeFrame(rightEyeOpen, ctx, rightEyeBounds, rightEyeBuffer, rightMaskData, currentPupilX, currentPupilY);

                    animationFrameRef.current = requestAnimationFrame(loop);
                };
                loop();

                if (useTTS) {
                    const u = new SpeechSynthesisUtterance(text);

                    // Intelligent voice selection based on profile parameters
                    const selectBestVoice = () => {
                        if (voices.length === 0) return null;

                        // Score each voice based on profile parameters
                        const scoredVoices = voices.map(v => {
                            let score = 0;
                            const name = v.name.toLowerCase();
                            const lang = (v.lang || '').toLowerCase();

                            // Gender matching (highest priority)
                            if (voiceGender === 'female') {
                                if (name.includes('female') || name.includes('woman') || name.includes('lady') || name.includes('girl')) score += 100;
                                else if (!name.includes('male') && !name.includes('man') && !name.includes('boy')) score += 50;
                            } else {
                                if (name.includes('male') || name.includes('man') || name.includes('boy')) score += 100;
                                else if (name.includes('david') || name.includes('james') || name.includes('daniel')) score += 80;
                            }

                            // Accent matching
                            if (voiceAccent === 'british' && (lang.includes('gb') || name.includes('british') || name.includes('daniel'))) score += 50;
                            else if (voiceAccent === 'american' && (lang.includes('us') || name.includes('american'))) score += 50;
                            else if (voiceAccent === 'australian' && (lang.includes('au') || name.includes('australian'))) score += 50;
                            else if (voiceAccent === 'neutral' && lang.includes('en')) score += 30;

                            // Timbre preference (based on voice name hints)
                            if (voiceTimbre === 'warm' && (name.includes('natural') || name.includes('daniel') || name.includes('samantha'))) score += 20;
                            else if (voiceTimbre === 'bright' && (name.includes('enhanced') || name.includes('premium'))) score += 20;
                            else if (voiceTimbre === 'neutral') score += 10;

                            // Prefer premium/enhanced voices
                            if (name.includes('premium') || name.includes('enhanced') || name.includes('natural')) score += 15;

                            return { voice: v, score };
                        });

                        // Sort by score and return best match
                        scoredVoices.sort((a, b) => b.score - a.score);
                        return scoredVoices[0].voice;
                    };

                    const selectedVoice = selectBestVoice();
                    if (selectedVoice) u.voice = selectedVoice;

                    // Apply voice controls
                    u.rate = voiceRate; // 0.1 to 2
                    u.pitch = voicePitch; // 0 to 2
                    u.volume = voiceVolume; // 0 to 1

                    u.onend = stopEverything;
                    window.speechSynthesis.speak(u);
                }
            };

            const stopEverything = () => {
                setIsAnimating(false);
                if(animationFrameRef.current) cancelAnimationFrame(animationFrameRef.current);
                if(mediaRecorderRef.current && mediaRecorderRef.current.state !== 'inactive') mediaRecorderRef.current.stop();
                if(audioRef.current) { audioRef.current.pause(); audioRef.current.currentTime = 0; }
                window.speechSynthesis.cancel();
                if(canvasRef.current && originalImageDataRef.current) {
                    const ctx = canvasRef.current.getContext('2d');
                    ctx.putImageData(originalImageDataRef.current, 0, 0);
                    drawOverlay();
                }
            };

            const handleImageUpload = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (ev) => {
                    const img = new Image();
                    img.onload = () => {
                        imageRef.current = img;
                        setImage(ev.target.result);
                        setPolyPoints([]); setLeftEyePoints([]); setRightEyePoints([]); setRecordedVideo(null);
                        setTimeout(() => {
                            const cvs = canvasRef.current;
                            const ctx = cvs.getContext('2d');
                            const MAX = 1920; 
                            const scale = Math.min(1, MAX / img.width);
                            cvs.width = Math.round(img.width * scale);
                            cvs.height = Math.round(img.height * scale);
                            ctx.imageSmoothingQuality = 'high';
                            ctx.drawImage(img, 0, 0, cvs.width, cvs.height);
                            originalImageDataRef.current = ctx.getImageData(0, 0, cvs.width, cvs.height);
                        }, 50);
                    };
                    img.src = ev.target.result;
                };
                reader.readAsDataURL(file);
            };

            const autoDetect = async () => {
                setIsDetecting(true);
                setStatus("Scanning for faces...");

                try {
                    const srcCvs = canvasRef.current;
                    if (!srcCvs) return;

                    // Multiple detection configurations to try (more robust for various image sizes)
                    // Start with larger input sizes and lower thresholds for better detection
                    const detectionConfigs = [
                        { inputSize: 512, scoreThreshold: 0.3, upscale: 1 },
                        { inputSize: 416, scoreThreshold: 0.25, upscale: 1 },
                        { inputSize: 320, scoreThreshold: 0.2, upscale: 1 },
                        { inputSize: 224, scoreThreshold: 0.15, upscale: 1 },
                        // For small faces, upscale the detection canvas
                        { inputSize: 512, scoreThreshold: 0.2, upscale: 2 },
                        { inputSize: 416, scoreThreshold: 0.15, upscale: 2 },
                        // Even more aggressive upscaling for tiny faces
                        { inputSize: 512, scoreThreshold: 0.1, upscale: 3 },
                    ];

                    let detection = null;
                    let usedScale = 1;
                    let configIndex = 0;

                    for (const config of detectionConfigs) {
                        configIndex++;
                        setStatus(`Scanning (attempt ${configIndex}/${detectionConfigs.length})...`);

                        // Calculate scale: may upscale for small images, cap to reasonable size
                        const upscaleFactor = config.upscale;
                        const maxDetectionSize = 1024;
                        const upscaledWidth = srcCvs.width * upscaleFactor;
                        const upscaledHeight = srcCvs.height * upscaleFactor;

                        // Limit maximum size to avoid memory issues
                        const finalScale = Math.min(
                            upscaleFactor,
                            maxDetectionSize / Math.max(srcCvs.width, srcCvs.height)
                        );

                        const detCvs = document.createElement("canvas");
                        detCvs.width = Math.round(srcCvs.width * finalScale);
                        detCvs.height = Math.round(srcCvs.height * finalScale);

                        const dctx = detCvs.getContext("2d", { willReadFrequently: true });

                        // Use better image smoothing for upscaling
                        dctx.imageSmoothingEnabled = true;
                        dctx.imageSmoothingQuality = 'high';
                        dctx.drawImage(srcCvs, 0, 0, detCvs.width, detCvs.height);

                        const opts = new faceapi.TinyFaceDetectorOptions({
                            inputSize: config.inputSize,
                            scoreThreshold: config.scoreThreshold,
                        });

                        try {
                            detection = await faceapi
                                .detectSingleFace(detCvs, opts)
                                .withFaceLandmarks();

                            if (detection) {
                                usedScale = finalScale;
                                console.log(`Face detected with config ${configIndex}: inputSize=${config.inputSize}, threshold=${config.scoreThreshold}, upscale=${config.upscale}`);
                                break;
                            }
                        } catch (e) {
                            console.warn(`Detection attempt ${configIndex} failed:`, e);
                            continue;
                        }
                    }

                    if (detection) {
                        const mouth = detection.landmarks.getMouth();

                        // Outer mouth ring (first 12 points), mapped back to original canvas coords
                        const outer = mouth.slice(0, 12).map((p) => ({ x: p.x / usedScale, y: p.y / usedScale }));

                        const center = outer.reduce((acc, p) => ({ x: acc.x + p.x, y: acc.y + p.y }), { x: 0, y: 0 });
                        center.x /= outer.length;
                        center.y /= outer.length;

                        // Calculate expansion based on face size for better scaling
                        const detectedMouthBounds = getBounds(outer);
                        const faceRelativeSize = Math.max(detectedMouthBounds.width, detectedMouthBounds.height) / Math.max(srcCvs.width, srcCvs.height);

                        // Adjust expansion: smaller faces need less expansion
                        const horizontalExpand = faceRelativeSize < 0.1 ? 1.25 : 1.4;
                        const verticalExpand = faceRelativeSize < 0.1 ? 1.15 : 1.3;

                        const expanded = outer.map((p) => ({
                            x: center.x + (p.x - center.x) * horizontalExpand,
                            y: center.y + (p.y - center.y) * verticalExpand,
                        }));

                        // Depth "chin bag" scaled to mouth size
                        const b = getBounds(expanded);
                        const chinDrop = Math.min(b.height * 0.25, Math.max(b.height * 0.15, 20));
                        for (let i = 6; i <= 10; i++) if (expanded[i]) expanded[i].y += chinDrop;

                        setPolyPoints(expanded);
                        setLipSplit(0.5);

                        // Eyes (separate polygons)
                        const leftEye = detection.landmarks.getLeftEye().map(p => ({x: p.x / usedScale, y: p.y / usedScale}));
                        const rightEye = detection.landmarks.getRightEye().map(p => ({x: p.x / usedScale, y: p.y / usedScale}));
                        setLeftEyePoints(leftEye);
                        setRightEyePoints(rightEye);

                        // Eyebrows (separate polygons)
                        const leftEyebrow = detection.landmarks.getLeftEyeBrow().map(p => ({x: p.x / usedScale, y: p.y / usedScale}));
                        const rightEyebrow = detection.landmarks.getRightEyeBrow().map(p => ({x: p.x / usedScale, y: p.y / usedScale}));
                        setLeftBrowPoints(leftEyebrow);
                        setRightBrowPoints(rightEyebrow);

                        // Generate companion regions for realistic animation
                        const nose = detection.landmarks.getNose().map(p => ({x: p.x / usedScale, y: p.y / usedScale}));
                        const jawOutline = detection.landmarks.getJawOutline().map(p => ({x: p.x / usedScale, y: p.y / usedScale}));

                        // Mouth companion regions
                        const mouthBounds = getBounds(expanded);
                        const mouthCenterX = (mouthBounds.x + mouthBounds.width / 2);
                        const mouthCenterY = (mouthBounds.y + mouthBounds.height / 2);

                        // Chin region (lower jaw that moves down with mouth)
                        const chinRegion = [];
                        for (let i = 5; i <= 11; i++) {
                            if (jawOutline[i]) {
                                chinRegion.push(jawOutline[i]);
                            }
                        }

                        // Cheek regions (sides of face that move with mouth)
                        const leftCheekRegion = [
                            expanded[0], // Left corner of mouth
                            {x: expanded[0].x - mouthBounds.width * 0.3, y: expanded[0].y},
                            {x: expanded[0].x - mouthBounds.width * 0.3, y: expanded[0].y - mouthBounds.height * 0.5},
                            {x: expanded[1].x, y: expanded[1].y - mouthBounds.height * 0.3}
                        ];

                        const rightCheekRegion = [
                            expanded[6], // Right corner of mouth
                            {x: expanded[6].x + mouthBounds.width * 0.3, y: expanded[6].y},
                            {x: expanded[6].x + mouthBounds.width * 0.3, y: expanded[6].y - mouthBounds.height * 0.5},
                            {x: expanded[5].x, y: expanded[5].y - mouthBounds.height * 0.3}
                        ];

                        // Bottom of nose region (subtle movement with mouth)
                        const noseBottomRegion = nose.slice(3, 6); // Bottom part of nose

                        setMouthCompanionRegions({
                            chin: chinRegion,
                            leftCheek: leftCheekRegion,
                            rightCheek: rightCheekRegion,
                            noseBottom: noseBottomRegion
                        });

                        // Eye companion regions
                        const leftEyeBounds = getBounds(leftEye);
                        const rightEyeBounds = getBounds(rightEye);

                        // Eye corners for squinting
                        const leftEyeCorners = [
                            leftEye[0], // Outer corner
                            {x: leftEye[0].x - 5, y: leftEye[0].y - 5},
                            {x: leftEye[0].x - 5, y: leftEye[0].y + 5}
                        ];

                        const rightEyeCorners = [
                            rightEye[3], // Outer corner
                            {x: rightEye[3].x + 5, y: rightEye[3].y - 5},
                            {x: rightEye[3].x + 5, y: rightEye[3].y + 5}
                        ];

                        // Upper cheek regions (below eyes, affected by blinking)
                        const leftUpperCheek = [
                            leftEye[4], // Bottom of left eye
                            leftEye[5],
                            {x: leftEyeBounds.x + leftEyeBounds.width, y: leftEyeBounds.y + leftEyeBounds.height + 10},
                            {x: leftEyeBounds.x, y: leftEyeBounds.y + leftEyeBounds.height + 10}
                        ];

                        const rightUpperCheek = [
                            rightEye[4], // Bottom of right eye
                            rightEye[5],
                            {x: rightEyeBounds.x + rightEyeBounds.width, y: rightEyeBounds.y + rightEyeBounds.height + 10},
                            {x: rightEyeBounds.x, y: rightEyeBounds.y + rightEyeBounds.height + 10}
                        ];

                        // Nose bridge (area between eyes)
                        const noseBridgeRegion = nose.slice(0, 3); // Top part of nose

                        setEyeCompanionRegions({
                            leftEyeCorners: leftEyeCorners,
                            rightEyeCorners: rightEyeCorners,
                            leftUpperCheek: leftUpperCheek,
                            rightUpperCheek: rightUpperCheek,
                            noseBridge: noseBridgeRegion
                        });

                        // Brow companion regions
                        const leftBrowBounds = getBounds(leftEyebrow);
                        const rightBrowBounds = getBounds(rightEyebrow);

                        // Forehead regions (move with eyebrows)
                        const leftForeheadRegion = [
                            leftEyebrow[0],
                            leftEyebrow[4],
                            {x: leftBrowBounds.x + leftBrowBounds.width, y: leftBrowBounds.y - 20},
                            {x: leftBrowBounds.x, y: leftBrowBounds.y - 20}
                        ];

                        const rightForeheadRegion = [
                            rightEyebrow[0],
                            rightEyebrow[4],
                            {x: rightBrowBounds.x + rightBrowBounds.width, y: rightBrowBounds.y - 20},
                            {x: rightBrowBounds.x, y: rightBrowBounds.y - 20}
                        ];

                        // Upper eyelid regions (affected by brow movement)
                        const leftEyelidUpper = [
                            leftEye[1],
                            leftEye[2],
                            leftEyebrow[2],
                            leftEyebrow[1]
                        ];

                        const rightEyelidUpper = [
                            rightEye[1],
                            rightEye[2],
                            rightEyebrow[2],
                            rightEyebrow[1]
                        ];

                        setBrowCompanionRegions({
                            leftForehead: leftForeheadRegion,
                            rightForehead: rightForeheadRegion,
                            leftEyelidUpper: leftEyelidUpper,
                            rightEyelidUpper: rightEyelidUpper
                        });

                        // Generate initial lip line
                        const finalMouthBounds = getBounds(expanded);
                        setLipLinePoints(generateLipLine(finalMouthBounds));

                        saveToHistory();
                        drawOverlay();
                        setStatus("Detected face and eyes. Refine or animate!");
                    } else {
                        setStatus("No face detected. Try Manual Draw or use a clearer image.");
                    }
                } catch (e) {
                    console.error(e);
                    setStatus("Detection failed. Use Manual Draw.");
                }
                setIsDetecting(false);
            };

            const drawOverlay = () => {
                const ctx = canvasRef.current.getContext('2d');
                const cw = canvasRef.current.width;
                const ch = canvasRef.current.height;

                // Use component-level transformPointToCanvas with current zoom state
                const transformPt = (p) => transformPointToCanvas(p, isZoomed, zoomScale, panOffset);

                // Create a temporary canvas with the character image
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = cw;
                tempCanvas.height = ch;
                const tempCtx = tempCanvas.getContext('2d');

                // Use either the background-removed character or the original image
                // Use refs for immediate updates
                if (bgRemovalEnabledRef.current && characterMaskRef.current) {
                    tempCtx.drawImage(characterMaskRef.current, 0, 0);
                } else if (originalImageDataRef.current) {
                    tempCtx.putImageData(originalImageDataRef.current, 0, 0);
                }

                // Clear the main canvas and draw background
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, cw, ch);

                // Draw background based on type - use refs for immediate updates
                if (backgroundTypeRef.current === 'color') {
                    ctx.fillStyle = backgroundColorRef.current;
                    ctx.fillRect(0, 0, cw, ch);
                } else if (backgroundTypeRef.current === 'image' && backgroundImage) {
                    // Scale and center the background image
                    const bgAspect = backgroundImage.width / backgroundImage.height;
                    const canvasAspect = cw / ch;
                    let drawW, drawH, drawX, drawY;

                    if (bgAspect > canvasAspect) {
                        drawH = ch;
                        drawW = ch * bgAspect;
                        drawX = (cw - drawW) / 2;
                        drawY = 0;
                    } else {
                        drawW = cw;
                        drawH = cw / bgAspect;
                        drawX = 0;
                        drawY = (ch - drawH) / 2;
                    }
                    ctx.drawImage(backgroundImage, drawX, drawY, drawW, drawH);
                } else if (backgroundTypeRef.current === 'video' && backgroundVideoRef.current) {
                    // Draw current video frame as background
                    const video = backgroundVideoRef.current;
                    const bgAspect = video.videoWidth / video.videoHeight;
                    const canvasAspect = cw / ch;
                    let drawW, drawH, drawX, drawY;

                    if (bgAspect > canvasAspect) {
                        drawH = ch;
                        drawW = ch * bgAspect;
                        drawX = (cw - drawW) / 2;
                        drawY = 0;
                    } else {
                        drawW = cw;
                        drawH = cw / bgAspect;
                        drawX = 0;
                        drawY = (ch - drawH) / 2;
                    }
                    ctx.drawImage(video, drawX, drawY, drawW, drawH);
                }

                // Draw the character on top of the background - use ref for immediate updates
                if (bgRemovalEnabledRef.current && characterMaskRef.current) {
                    // Position the character based on characterPosition
                    const charW = tempCanvas.width * characterPosition.scale;
                    const charH = tempCanvas.height * characterPosition.scale;
                    const charX = (cw - charW) * characterPosition.x;
                    const charY = (ch - charH) * characterPosition.y;
                    ctx.drawImage(tempCanvas, charX, charY, charW, charH);
                } else if (isZoomed && zoomScale > 1.0) {
                    // Zoomed view
                    const viewportWidth = cw / zoomScale;
                    const viewportHeight = ch / zoomScale;
                    ctx.drawImage(
                        tempCanvas,
                        panOffset.x, panOffset.y, viewportWidth, viewportHeight,
                        0, 0, cw, ch
                    );
                    ctx.fillStyle = '#00ff99';
                    ctx.font = '14px sans-serif';
                    ctx.fillText(`ZOOM: ${zoomScale.toFixed(1)}x - Drag to pan, click selection to reposition`, 20, 30);
                } else {
                    // Normal view - just draw the image
                    if (originalImageDataRef.current) {
                        ctx.putImageData(originalImageDataRef.current, 0, 0);
                    }
                }

                // Draw grid if enabled
                if (showGrid) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([2, 2]);
                    for (let x = 0; x < cw; x += gridSize) {
                        ctx.beginPath();
                        ctx.moveTo(x, 0);
                        ctx.lineTo(x, ch);
                        ctx.stroke();
                    }
                    for (let y = 0; y < ch; y += gridSize) {
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(cw, y);
                        ctx.stroke();
                    }
                    ctx.setLineDash([]);
                }

                // Helper to draw anchor point with highlight
                const drawAnchorPoint = (p, index, type, color, outlineColor) => {
                    const pt = transformPt(p);
                    const isHovered = hoveredPoint && hoveredPoint.type === type && hoveredPoint.index === index;
                    const isDragging = draggedEye === type && draggedPointIndex === index;

                    // Draw glow for hovered/dragging points
                    if (isHovered || isDragging) {
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = isDragging ? '#ffff00' : '#ffffff';
                    }

                    ctx.beginPath();
                    const radius = getAnchorRadius() * (isHovered ? 1.3 : isDragging ? 1.5 : 1.0);
                    ctx.arc(pt.x, pt.y, radius, 0, Math.PI * 2);

                    // Fill with color
                    ctx.fillStyle = isDragging ? '#ffff00' : isHovered ? '#ffaaaa' : color;
                    ctx.fill();

                    // Draw outline
                    if (outlineColor) {
                        ctx.strokeStyle = outlineColor;
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }

                    // Reset shadow
                    ctx.shadowBlur = 0;
                };

                // Mouth (anchor points increased 25%: 4 -> 5)
                if (polyPointsRef.current.length > 0) {
                    ctx.strokeStyle = '#ff00ff'; ctx.lineWidth = 2;
                    ctx.beginPath();
                    const firstPt = transformPt(polyPointsRef.current[0]);
                    ctx.moveTo(firstPt.x, firstPt.y);
                    for (let i = 1; i < polyPointsRef.current.length; i++) {
                        const pt = transformPt(polyPointsRef.current[i]);
                        ctx.lineTo(pt.x, pt.y);
                    }
                    ctx.closePath(); ctx.stroke();

                    polyPointsRef.current.forEach((p, i) => {
                        drawAnchorPoint(p, i, 'mouth', '#fff', '#ff00ff');
                    });
                }

                // Eyes overlay for editing (anchor points increased 25%: 3 -> 4)
                const drawEyeOverlay = (eyePoints, eyeType) => {
                    if (eyePoints.length > 0) {
                        ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 2;
                        ctx.beginPath();
                        const firstPt = transformPt(eyePoints[0]);
                        ctx.moveTo(firstPt.x, firstPt.y);
                        for (let i = 1; i < eyePoints.length; i++) {
                            const pt = transformPt(eyePoints[i]);
                            ctx.lineTo(pt.x, pt.y);
                        }
                        ctx.closePath(); ctx.stroke();

                        eyePoints.forEach((p, i) => {
                            drawAnchorPoint(p, i, eyeType, '#fff', '#00ff00');
                        });
                    }
                };
                drawEyeOverlay(leftEyePointsRef.current, 'leftEye');
                drawEyeOverlay(rightEyePointsRef.current, 'rightEye');

                // Eyebrows overlay (separate from eyes, yellow/orange color)
                const drawBrowOverlay = (browPoints, browType) => {
                    if (browPoints.length > 0) {
                        ctx.strokeStyle = '#ffaa00'; ctx.lineWidth = 2;
                        ctx.beginPath();
                        const firstPt = transformPt(browPoints[0]);
                        ctx.moveTo(firstPt.x, firstPt.y);
                        for (let i = 1; i < browPoints.length; i++) {
                            const pt = transformPt(browPoints[i]);
                            ctx.lineTo(pt.x, pt.y);
                        }
                        ctx.closePath(); ctx.stroke();

                        browPoints.forEach((p, i) => {
                            drawAnchorPoint(p, i, browType, '#fff', '#ffaa00');
                        });
                    }
                };
                drawBrowOverlay(leftBrowPointsRef.current, 'leftBrow');
                drawBrowOverlay(rightBrowPointsRef.current, 'rightBrow');

                // Draw resize handles for all zones
                const drawResizeHandle = (points, color) => {
                    if (!points || points.length < 3) return;
                    const handlePos = getResizeHandlePos(points);
                    if (!handlePos) return;

                    const pt = transformPt(handlePos);
                    const handleSize = RESIZE_HANDLE_SIZE;

                    // Draw handle background
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(pt.x - handleSize/2, pt.y - handleSize/2, handleSize, handleSize);

                    // Draw handle border
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(pt.x - handleSize/2, pt.y - handleSize/2, handleSize, handleSize);

                    // Draw diagonal resize icon
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(pt.x - 4, pt.y + 4);
                    ctx.lineTo(pt.x + 4, pt.y - 4);
                    ctx.stroke();

                    // Draw arrows
                    ctx.beginPath();
                    ctx.moveTo(pt.x + 4, pt.y - 4);
                    ctx.lineTo(pt.x + 1, pt.y - 4);
                    ctx.moveTo(pt.x + 4, pt.y - 4);
                    ctx.lineTo(pt.x + 4, pt.y - 1);
                    ctx.moveTo(pt.x - 4, pt.y + 4);
                    ctx.lineTo(pt.x - 1, pt.y + 4);
                    ctx.moveTo(pt.x - 4, pt.y + 4);
                    ctx.lineTo(pt.x - 4, pt.y + 1);
                    ctx.stroke();
                };

                // Draw resize handles for each zone
                if (polyPointsRef.current.length > 0) {
                    drawResizeHandle(polyPointsRef.current, '#ff00ff');
                }
                if (leftEyePointsRef.current.length > 0) {
                    drawResizeHandle(leftEyePointsRef.current, '#00ff00');
                }
                if (rightEyePointsRef.current.length > 0) {
                    drawResizeHandle(rightEyePointsRef.current, '#00ff00');
                }
                if (leftBrowPointsRef.current.length > 0) {
                    drawResizeHandle(leftBrowPointsRef.current, '#ffaa00');
                }
                if (rightBrowPointsRef.current.length > 0) {
                    drawResizeHandle(rightBrowPointsRef.current, '#ffaa00');
                }


                // Editable lip line (anchor points increased 25%: 4 -> 5)
                if (lipLinePointsRef.current.length > 0) {
                    ctx.strokeStyle = '#00ff99';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    for (let i = 0; i < lipLinePointsRef.current.length; i++) {
                        const pt = transformPt(lipLinePointsRef.current[i]);
                        if (i === 0) ctx.moveTo(pt.x, pt.y);
                        else ctx.lineTo(pt.x, pt.y);
                    }
                    ctx.stroke();

                    // Draw anchor points with enhanced visualization
                    lipLinePointsRef.current.forEach((p, i) => {
                        drawAnchorPoint(p, i, 'lipLine', '#00ff99', null);
                    });
                }

                // Lip width box (visual guide)
                if (polyPointsRef.current.length > 0) {
                    const b = getBounds(polyPointsRef.current);
                    const lipW = b.width * params.current.lipWidth;
                    const lx = b.x + (b.width - lipW) / 2;
                    const baseSplitY = b.y + (b.height * params.current.lipSplit);

                    ctx.strokeStyle = '#ffae00';
                    ctx.lineWidth = 1;
                    // Transform the rectangle corners when zoomed
                    const topLeft = transformPt({ x: lx, y: baseSplitY - 10 });
                    const bottomRight = transformPt({ x: lx + lipW, y: baseSplitY + 10 });
                    ctx.strokeRect(topLeft.x, topLeft.y, bottomRight.x - topLeft.x, bottomRight.y - topLeft.y);
                }

                // Display coordinate and modifier status when dragging
                if (draggedPointIndex !== null && draggedEye) {
                    let currentPoints;
                    if (draggedEye === 'mouth') currentPoints = polyPointsRef.current;
                    else if (draggedEye === 'leftEye') currentPoints = leftEyePointsRef.current;
                    else if (draggedEye === 'rightEye') currentPoints = rightEyePointsRef.current;
                    else if (draggedEye === 'leftBrow') currentPoints = leftBrowPointsRef.current;
                    else if (draggedEye === 'rightBrow') currentPoints = rightBrowPointsRef.current;
                    else if (draggedEye === 'lipLine') currentPoints = lipLinePointsRef.current;

                    if (currentPoints && currentPoints[draggedPointIndex]) {
                        const pt = currentPoints[draggedPointIndex];
                        const canvasPt = transformPt(pt);

                        // Draw coordinate display
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                        ctx.fillRect(canvasPt.x + 15, canvasPt.y - 35, 120, 30);
                        ctx.fillStyle = '#ffff00';
                        ctx.font = '12px monospace';
                        ctx.fillText(`X: ${Math.round(pt.x)} Y: ${Math.round(pt.y)}`, canvasPt.x + 20, canvasPt.y - 15);
                    }
                }

                // Display keyboard modifier status
                const modifiers = [];
                if (keyModifiers.shift) modifiers.push(' AXIS LOCK');
                if (keyModifiers.ctrl) modifiers.push(' PRECISION');
                if (keyModifiers.alt || snapToGrid) modifiers.push(' SNAP');
                if (showGrid) modifiers.push('GRID');

                if (modifiers.length > 0 || showGrid || snapToGrid) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(10, ch - 40, 300, 30);
                    ctx.fillStyle = '#00ff99';
                    ctx.font = 'bold 14px sans-serif';
                    ctx.fillText(modifiers.join(' | '), 15, ch - 18);
                }

                // Display help text
                if (!isAnimating && image && !isDraggingPoly && draggedPointIndex === null) {
                    const helpText = 'G:Grid | Shift:Lock Axis | Ctrl:Precision | Alt:Snap';
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    const textWidth = ctx.measureText(helpText).width;
                    ctx.fillRect(cw - textWidth - 20, 10, textWidth + 10, 20);
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '12px sans-serif';
                    ctx.fillText(helpText, cw - textWidth - 15, 24);
                }
            };

            const resetAll = () => {
                stopEverything();
                setImage(null);
                setRecordedVideo(null);
                setPolyPoints([]);
                setLipLinePoints([]);
                setLeftEyePoints([]);
                setRightEyePoints([]);
                setLeftBrowPoints([]);
                setRightBrowPoints([]);
            };

            return (
                <div className="layout">
                    <div
                        className="stage"
                        onMouseDown={handleMouseDown}
                        onMouseMove={handleMouseMove}
                        onMouseUp={handleMouseUp}
                        onMouseLeave={handleMouseUp}
                        onWheel={handleWheel}
                        onDoubleClick={handleDoubleClick}
                        onTouchStart={handleTouchStart}
                        onTouchMove={handleTouchMove}
                        onTouchEnd={handleTouchEnd}
                    >
                        {!image && <div className="upload-zone" onClick={()=>document.getElementById('imgIn').click()}><h2>Upload Photo</h2><p>High Resolution Recommended</p><input id="imgIn" type="file" onChange={handleImageUpload} style={{display:'none'}} accept="image/*" /></div>}
                        <canvas
                            ref={canvasRef}
                            style={{opacity: image?1:0, touchAction: 'none'}}
                            onMouseDown={handleMouseDown}
                            onMouseMove={handleMouseMove}
                            onMouseUp={handleMouseUp}
                            onMouseLeave={handleMouseUp}
                            onWheel={handleWheel}
                            onTouchStart={handleTouchStart}
                            onTouchMove={handleTouchMove}
                            onTouchEnd={handleTouchEnd}
                            onDoubleClick={handleDoubleClick}
                        />
                        {isDetecting && <div className="overlay-msg"><div className="spinner"></div><span>Scanning Face...</span></div>}
                    </div>

                    <div className="controls">
                        <h1>Lip Sync Pro</h1>
                        <div className="panel">
                            <h3>Setup</h3>
                            <div className="btn-row" style={{marginBottom: 10}}>
                                <button className="btn btn-danger" onClick={resetAll}>Reset All</button>
                            </div>

                            <h3 style={{marginTop: 10, fontSize: '0.9rem'}}>Add Selection Zone</h3>
                            <div className="btn-row" style={{alignItems: 'center'}}>
                                <select
                                    value={manualDrawFeature}
                                    onChange={e => setManualDrawFeature(e.target.value)}
                                    disabled={!image || isAnimating || manualDrawMode}
                                    style={{
                                        flex: 1,
                                        padding: '10px',
                                        borderRadius: '6px',
                                        border: '1px solid #444',
                                        background: '#2a2a2a',
                                        color: '#fff',
                                        fontSize: '0.85rem',
                                        cursor: 'pointer'
                                    }}
                                >
                                    <option value="mouth">Mouth</option>
                                    <option value="leftEye">Left Eye</option>
                                    <option value="rightEye">Right Eye</option>
                                    <option value="leftBrow">Left Eyebrow</option>
                                    <option value="rightBrow">Right Eyebrow</option>
                                </select>
                                <button
                                    className={`btn ${manualDrawMode ? 'btn-primary' : ''}`}
                                    onClick={() => {
                                        if (manualDrawMode) {
                                            setManualDrawMode(false);
                                            setShapePreviewPos(null);
                                            drawOverlay();
                                        } else {
                                            setManualDrawMode(true);
                                            setShapePreviewPos(null);
                                        }
                                    }}
                                    disabled={!image || isAnimating}
                                    title="Click to place a shape, then drag corners to resize"
                                    style={{minWidth: '100px'}}
                                >
                                    {manualDrawMode ? 'Cancel' : 'Drop'}
                                </button>
                            </div>
                            {manualDrawMode && (
                                <p style={{fontSize: '0.75rem', color: '#ff9900', marginTop: 8}}>
                                    Click anywhere to place the {manualDrawFeature} shape.
                                </p>
                            )}

                            <div className="hint">
                                Tip: Drag the corner handle to resize zones. Drag points to adjust shape. Drag inside to move.
                            </div>
                        </div>

                        <div className="panel">
                            <h3>Background Removal</h3>
                            <div className="btn-row">
                                <button
                                    className="btn"
                                    onClick={removeBackground}
                                    disabled={!image || isAnimating || isRemovingBg}
                                >
                                    {isRemovingBg ? 'Processing...' : 'Remove Background'}
                                </button>
                                <button
                                    className="btn btn-danger"
                                    onClick={resetBackgroundRemoval}
                                    disabled={!bgRemovalEnabled}
                                >
                                    Reset
                                </button>
                            </div>
                            {bgRemovalEnabled && (
                                <>
                                    <div className="slider-row" style={{marginTop: 10}}>
                                        <label>Threshold</label>
                                        <input
                                            type="range"
                                            min="0.1"
                                            max="0.9"
                                            step="0.05"
                                            value={bgRemovalThreshold}
                                            onChange={e => { setBgRemovalThreshold(Number(e.target.value)); removeBackground(); }}
                                        />
                                        <span style={{fontSize: '0.7rem', color: '#888'}}>{bgRemovalThreshold.toFixed(2)}</span>
                                    </div>
                                    <div className="slider-row">
                                        <label>Edge Softness</label>
                                        <input
                                            type="range"
                                            min="0.01"
                                            max="0.3"
                                            step="0.01"
                                            value={bgRemovalEdge}
                                            onChange={e => { setBgRemovalEdge(Number(e.target.value)); removeBackground(); }}
                                        />
                                        <span style={{fontSize: '0.7rem', color: '#888'}}>{bgRemovalEdge.toFixed(2)}</span>
                                    </div>
                                </>
                            )}
                        </div>


                        <div className="panel">
                            <h3>Background</h3>
                            <div className="tabs" style={{marginBottom: 10}}>
                                <div className={`tab ${backgroundType === 'none' ? 'active' : ''}`} onClick={() => { backgroundTypeRef.current = 'none'; setBackgroundType('none'); drawOverlay(); }}>None</div>
                                <div className={`tab ${backgroundType === 'color' ? 'active' : ''}`} onClick={() => { backgroundTypeRef.current = 'color'; setBackgroundType('color'); drawOverlay(); }}>Color</div>
                                <div className={`tab ${backgroundType === 'image' ? 'active' : ''}`} onClick={() => { backgroundTypeRef.current = 'image'; setBackgroundType('image'); }}>Image</div>
                                <div className={`tab ${backgroundType === 'video' ? 'active' : ''}`} onClick={() => { backgroundTypeRef.current = 'video'; setBackgroundType('video'); }}>Video</div>
                            </div>

                            {backgroundType === 'color' && (
                                <div className="btn-row" style={{alignItems: 'center'}}>
                                    <label style={{fontSize: '0.8rem', color: '#aaa'}}>Color:</label>
                                    <input
                                        type="color"
                                        value={backgroundColor}
                                        onChange={e => { backgroundColorRef.current = e.target.value; setBackgroundColor(e.target.value); drawOverlay(); }}
                                        style={{flex: 1, height: 35, cursor: 'pointer'}}
                                    />
                                </div>
                            )}

                            {backgroundType === 'image' && (
                                <div className="btn-row">
                                    <button className="btn" onClick={() => document.getElementById('bgImgIn').click()}>
                                        {backgroundImage ? 'Change Image' : 'Load Image'}
                                    </button>
                                    <input id="bgImgIn" type="file" onChange={handleBackgroundImageUpload} style={{display:'none'}} accept="image/*" />
                                    {backgroundImage && (
                                        <button className="btn btn-danger" onClick={clearBackground}>Clear</button>
                                    )}
                                </div>
                            )}

                            {backgroundType === 'video' && (
                                <div className="btn-row">
                                    <button className="btn" onClick={() => document.getElementById('bgVidIn').click()}>
                                        {backgroundVideo ? 'Change Video' : 'Load Video'}
                                    </button>
                                    <input id="bgVidIn" type="file" onChange={handleBackgroundVideoUpload} style={{display:'none'}} accept="video/*" />
                                    {backgroundVideo && (
                                        <button className="btn btn-danger" onClick={clearBackground}>Clear</button>
                                    )}
                                </div>
                            )}

                            {bgRemovalEnabled && backgroundType !== 'none' && (
                                <>
                                    <h3 style={{marginTop: 15, fontSize: '0.9rem'}}>Character Position</h3>
                                    <div className="slider-row">
                                        <label>Horizontal</label>
                                        <input
                                            type="range"
                                            min="0"
                                            max="1"
                                            step="0.01"
                                            value={characterPosition.x}
                                            onChange={e => { setCharacterPosition(prev => ({...prev, x: Number(e.target.value)})); drawOverlay(); }}
                                        />
                                        <span style={{fontSize: '0.7rem', color: '#888'}}>{(characterPosition.x * 100).toFixed(0)}%</span>
                                    </div>
                                    <div className="slider-row">
                                        <label>Vertical</label>
                                        <input
                                            type="range"
                                            min="0"
                                            max="1"
                                            step="0.01"
                                            value={characterPosition.y}
                                            onChange={e => { setCharacterPosition(prev => ({...prev, y: Number(e.target.value)})); drawOverlay(); }}
                                        />
                                        <span style={{fontSize: '0.7rem', color: '#888'}}>{(characterPosition.y * 100).toFixed(0)}%</span>
                                    </div>
                                    <div className="slider-row">
                                        <label>Scale</label>
                                        <input
                                            type="range"
                                            min="0.2"
                                            max="2"
                                            step="0.05"
                                            value={characterPosition.scale}
                                            onChange={e => { setCharacterPosition(prev => ({...prev, scale: Number(e.target.value)})); drawOverlay(); }}
                                        />
                                        <span style={{fontSize: '0.7rem', color: '#888'}}>{(characterPosition.scale * 100).toFixed(0)}%</span>
                                    </div>
                                </>
                            )}
                        </div>

                        <div className="panel">
                            <h3>Undo/Redo</h3>
                            <div className="btn-row">
                                <button className="btn" onClick={undo} disabled={historyIndex <= 0}>
                                    Undo
                                </button>
                                <button className="btn" onClick={redo} disabled={historyIndex >= history.length - 1}>
                                    Redo
                                </button>
                            </div>
                            <p style={{fontSize: '0.7rem', color: '#888', marginTop: 5}}>
                                {history.length > 0 ? `${historyIndex + 1} / ${history.length}` : 'No history'}
                            </p>
                        </div>


                        <div className="panel">
                            <h3>Audio Source</h3>
                            <div className="tabs">
                                <div className={`tab ${audioSource==='none'?'active':''}`} onClick={()=>setAudioSource('none')}>None</div>
                                <div className={`tab ${audioSource==='file'?'active':''}`} onClick={()=>setAudioSource('file')}>File</div>
                                <div className={`tab ${audioSource==='record'?'active':''}`} onClick={()=>setAudioSource('record')}>Record</div>
                                <div className={`tab ${audioSource==='video'?'active':''}`} onClick={()=>setAudioSource('video')}>Video</div>
                                <div className={`tab ${audioSource==='tts'?'active':''}`} onClick={()=>setAudioSource('tts')}>TTS</div>
                            </div>

                            {audioSource === 'none' && (
                                <div style={{padding: '15px 0', color: '#888', textAlign: 'center', fontSize: '0.85rem'}}>
                                    Animation will play without audio.<br/>
                                    Mouth will use fallback sine wave motion.
                                </div>
                            )}

                            {audioSource === 'file' && (
                                <div>
                                    <input type="file" accept="audio/*" onChange={(e)=>{if(e.target.files[0]){setAudioUrl(URL.createObjectURL(e.target.files[0])); setActiveTab('audio');}}} style={{marginTop: 10}} />
                                    {audioUrl && <audio src={audioUrl} controls style={{width:'100%', marginTop:10}} />}
                                </div>
                            )}

                            {audioSource === 'record' && (
                                <div>
                                    <div className="btn-row" style={{marginTop: 10}}>
                                        <button className="btn" onClick={startVoiceRecord} disabled={isRecordingVoice}>Record Voice</button>
                                        <button className="btn btn-danger" onClick={stopVoiceRecord} disabled={!isRecordingVoice}>Stop Recording</button>
                                    </div>
                                    {audioUrl && <audio src={audioUrl} controls style={{width:'100%', marginTop:10}} />}
                                </div>
                            )}

                            {audioSource === 'video' && (
                                <div style={{padding: '10px 0'}}>
                                    {backgroundType === 'video' && backgroundVideo ? (
                                        <div style={{color: '#00ff99', fontSize: '0.85rem'}}>
                                            Audio will be synced from the loaded background video.
                                        </div>
                                    ) : (
                                        <div style={{color: '#ff6666', fontSize: '0.85rem'}}>
                                            Load a background video first to use its audio.
                                        </div>
                                    )}
                                </div>
                            )}

                            {audioSource === 'tts' && (
                                <div>
                                    <textarea value={text} onChange={e=>setText(e.target.value)} style={{width:'100%', background:'#1a1a1a', color:'#fff', border:'none', padding:10, borderRadius:4, minHeight:60}} />

                                    <h3 style={{marginTop: 15, fontSize: '0.8rem'}}>Voice Customization</h3>

                                    <div style={{marginTop: 10}}>
                                        <label style={{fontSize: '0.8rem', color: '#aaa', marginBottom: 5, display: 'block'}}>Gender</label>
                                        <div className="btn-row">
                                            <button
                                                className={`btn ${voiceGender === 'female' ? 'btn-primary' : ''}`}
                                                onClick={() => setVoiceGender('female')}
                                                style={{flex: 1}}
                                            >
                                                Female
                                            </button>
                                            <button
                                                className={`btn ${voiceGender === 'male' ? 'btn-primary' : ''}`}
                                                onClick={() => setVoiceGender('male')}
                                                style={{flex: 1}}
                                            >
                                                Male
                                            </button>
                                        </div>
                                    </div>

                                    <div className="slider-row" style={{marginTop: 10}}>
                                        <label>Speed</label>
                                        <input type="range" min="0.1" max="2" step="0.1" value={voiceRate} onChange={e=>setVoiceRate(Number(e.target.value))} />
                                        <span style={{fontSize: '0.7rem', color: '#888'}}>{voiceRate.toFixed(1)}x</span>
                                    </div>

                                    <div className="slider-row">
                                        <label>Pitch</label>
                                        <input type="range" min="0" max="2" step="0.1" value={voicePitch} onChange={e=>setVoicePitch(Number(e.target.value))} />
                                        <span style={{fontSize: '0.7rem', color: '#888'}}>{voicePitch.toFixed(1)}</span>
                                    </div>

                                    <div className="slider-row">
                                        <label>Volume</label>
                                        <input type="range" min="0" max="1" step="0.1" value={voiceVolume} onChange={e=>setVoiceVolume(Number(e.target.value))} />
                                        <span style={{fontSize: '0.7rem', color: '#888'}}>{(voiceVolume * 100).toFixed(0)}%</span>
                                    </div>

                                    <div style={{marginTop: 15}}>
                                        <label style={{fontSize: '0.8rem', color: '#aaa', marginBottom: 5, display: 'block'}}>Timbre</label>
                                        <div className="btn-row">
                                            <button
                                                className={`btn ${voiceTimbre === 'warm' ? 'btn-primary' : ''}`}
                                                onClick={() => setVoiceTimbre('warm')}
                                                style={{flex: 1, fontSize: '0.75rem'}}
                                            >
                                                Warm
                                            </button>
                                            <button
                                                className={`btn ${voiceTimbre === 'neutral' ? 'btn-primary' : ''}`}
                                                onClick={() => setVoiceTimbre('neutral')}
                                                style={{flex: 1, fontSize: '0.75rem'}}
                                            >
                                                Neutral
                                            </button>
                                            <button
                                                className={`btn ${voiceTimbre === 'bright' ? 'btn-primary' : ''}`}
                                                onClick={() => setVoiceTimbre('bright')}
                                                style={{flex: 1, fontSize: '0.75rem'}}
                                            >
                                                Bright
                                            </button>
                                        </div>
                                    </div>

                                    <div style={{marginTop: 15}}>
                                        <label style={{fontSize: '0.8rem', color: '#aaa', marginBottom: 5, display: 'block'}}>Accent</label>
                                        <div className="btn-row" style={{marginBottom: 5}}>
                                            <button
                                                className={`btn ${voiceAccent === 'neutral' ? 'btn-primary' : ''}`}
                                                onClick={() => setVoiceAccent('neutral')}
                                                style={{flex: 1, fontSize: '0.75rem'}}
                                            >
                                                Neutral
                                            </button>
                                            <button
                                                className={`btn ${voiceAccent === 'american' ? 'btn-primary' : ''}`}
                                                onClick={() => setVoiceAccent('american')}
                                                style={{flex: 1, fontSize: '0.75rem'}}
                                            >
                                                American
                                            </button>
                                        </div>
                                        <div className="btn-row">
                                            <button
                                                className={`btn ${voiceAccent === 'british' ? 'btn-primary' : ''}`}
                                                onClick={() => setVoiceAccent('british')}
                                                style={{flex: 1, fontSize: '0.75rem'}}
                                            >
                                                British
                                            </button>
                                            <button
                                                className={`btn ${voiceAccent === 'australian' ? 'btn-primary' : ''}`}
                                                onClick={() => setVoiceAccent('australian')}
                                                style={{flex: 1, fontSize: '0.75rem'}}
                                            >
                                                Australian
                                            </button>
                                        </div>
                                    </div>

                                    <h3 style={{marginTop: 20, fontSize: '0.8rem', borderTop: '1px solid #333', paddingTop: 15}}>Voice Profiles</h3>

                                    <div style={{marginTop: 10}}>
                                        <div className="btn-row" style={{marginBottom: 10}}>
                                            <input
                                                id="profileNameInput"
                                                type="text"
                                                placeholder="Profile name..."
                                                style={{flex: 1, background:'#1a1a1a', color:'#fff', border:'1px solid #333', padding:6, borderRadius:4, fontSize:'0.8rem'}}
                                            />
                                            <button
                                                className="btn btn-primary"
                                                onClick={() => {
                                                    const input = document.getElementById('profileNameInput');
                                                    if (input && input.value) {
                                                        saveVoiceProfile(input.value);
                                                        input.value = '';
                                                    }
                                                }}
                                                style={{fontSize: '0.75rem'}}
                                            >
                                                Save
                                            </button>
                                        </div>

                                        <div style={{marginBottom: 10}}>
                                            <label htmlFor="importProfileInput" className="btn" style={{fontSize: '0.75rem', cursor: 'pointer', display: 'inline-block', textAlign: 'center'}}>
                                                Import Profile
                                            </label>
                                            <input
                                                id="importProfileInput"
                                                type="file"
                                                accept=".json"
                                                onChange={importVoiceProfile}
                                                style={{display: 'none'}}
                                            />
                                        </div>

                                        {savedVoiceProfiles.length > 0 && (
                                            <div style={{maxHeight: '200px', overflowY: 'auto', border: '1px solid #333', borderRadius: 4, padding: 8}}>
                                                {savedVoiceProfiles.map(profile => (
                                                    <div key={profile.name} style={{
                                                        background: '#1a1a1a',
                                                        padding: 8,
                                                        marginBottom: 6,
                                                        borderRadius: 4,
                                                        display: 'flex',
                                                        alignItems: 'center',
                                                        gap: 6
                                                    }}>
                                                        <div style={{flex: 1, fontSize: '0.8rem'}}>
                                                            <div style={{fontWeight: 'bold', marginBottom: 2}}>{profile.name}</div>
                                                            <div style={{fontSize: '0.7rem', color: '#888'}}>
                                                                {profile.gender}  {profile.accent}  {profile.timbre}
                                                            </div>
                                                        </div>
                                                        <button
                                                            className="btn btn-primary"
                                                            onClick={() => loadVoiceProfile(profile)}
                                                            style={{fontSize: '0.7rem', padding: '4px 8px'}}
                                                        >
                                                            Load
                                                        </button>
                                                        <button
                                                            className="btn"
                                                            onClick={() => exportVoiceProfile(profile)}
                                                            style={{fontSize: '0.7rem', padding: '4px 8px'}}
                                                        >
                                                            Export
                                                        </button>
                                                        <button
                                                            className="btn btn-danger"
                                                            onClick={() => deleteVoiceProfile(profile.name)}
                                                            style={{fontSize: '0.7rem', padding: '4px 8px'}}
                                                        >
                                                            
                                                        </button>
                                                    </div>
                                                ))}
                                            </div>
                                        )}
                                    </div>
                                </div>
                            )}
                        </div>

                        <div className="panel">
                            <h3>Lip Geometry</h3>
                            <div className="slider-row">
                                <label style={{color:'#ffae00'}}>Lip Width</label>
                                <input type="range" min="0.3" max="1.0" step="0.05" value={lipWidth} onChange={e=>setLipWidth(Number(e.target.value))} />
                            </div>
                            <div className="slider-row">
                                <label style={{color:'#00ff99'}}>Vertical Center</label>
                                <input type="range" min="0.3" max="0.7" step="0.01" value={lipSplit} onChange={e=>setLipSplit(Number(e.target.value))} />
                            </div>
                            <div className="slider-row">
                                <label>Cupid's Bow</label>
                                <input type="range" min="-1.0" max="1.0" step="0.05" value={cupidBow} onChange={e=>setCupidBow(Number(e.target.value))} />
                            </div>
                            <div className="slider-row">
                                <label>Smile Curve</label>
                                <input type="range" min="-0.5" max="0.5" step="0.05" value={lipCurve} onChange={e=>setLipCurve(Number(e.target.value))} />
                            </div>
                        </div>

                        <div className="panel">
                            <h3>3D Anatomy</h3>

                            <div className="slider-row">
                                <label>Jaw Gap</label>
                                <input type="range" min="0" max="0.3" step="0.01" value={jawGap} onChange={e=>setJawGap(Number(e.target.value))} />
                            </div>

                            <div className="slider-row">
                                <label>Teeth Brightness</label>
                                <input type="range" min="0.2" max="1" step="0.05" value={teethBrightness} onChange={e=>setTeethBrightness(Number(e.target.value))} />
                            </div>

                            <div className="slider-row">
                                <label>Teeth Vertical</label>
                                <input type="range" min="-0.2" max="0.2" step="0.01" value={teethVertical} onChange={e=>setTeethVertical(Number(e.target.value))} />
                            </div>

                            <div className="slider-row">
                                <label>Teeth Shade</label>
                                <input type="range" min="0" max="1" step="0.1" value={teethShade} onChange={e=>setTeethShade(Number(e.target.value))} />
                            </div>

                            <div className="slider-row">
                                <label>Tongue Height</label>
                                <input type="range" min="0" max="1.5" step="0.1" value={tongueHeight} onChange={e=>setTongueHeight(Number(e.target.value))} />
                            </div>

                            <div className="slider-row">
                                <label>Lip Lighten</label>
                                <input type="range" min="0" max="1" step="0.1" value={lipLighten} onChange={e=>setLipLighten(Number(e.target.value))} />
                            </div>

                            <div className="slider-row">
                                <label>Split Color</label>
                                <input type="range" min="0" max="1" step="0.05" value={splitColor} onChange={e=>setSplitColor(Number(e.target.value))} />
                            </div>

                            <div className="slider-row">
                                <label>Split Texture</label>
                                <input type="range" min="0" max="1" step="0.05" value={splitTexture} onChange={e=>setSplitTexture(Number(e.target.value))} />
                            </div>
                        </div>

                        <div className="panel">
                            <h3>Animation Tuning</h3>
                            <div className="slider-row">
                                <label>Sensitivity</label>
                                <input type="range" min="0.2" max="3" step="0.1" value={sensitivity} onChange={e=>setSensitivity(Number(e.target.value))} />
                            </div>

                            <div className="slider-row">
                                <label>Lip Roll</label>
                                <input type="range" min="0" max="1" step="0.05" value={lipRoll} onChange={e=>setLipRoll(Number(e.target.value))} />
                            </div>

                            <div className="slider-row">
                                <label>Syllable Snap</label>
                                <input type="range" min="0" max="1" step="0.05" value={syllableSnap} onChange={e=>setSyllableSnap(Number(e.target.value))} />
                            </div>

                            <div className="slider-row">
                                <label>Smoothing</label>
                                <input type="range" min="0.02" max="0.6" step="0.01" value={smoothing} onChange={e=>setSmoothing(Number(e.target.value))} />
                            </div>
                        </div>

                        <div className="panel">
                            <h3>Eye Animation Presets</h3>
                            <p style={{fontSize: '0.75rem', color: '#888', marginBottom: '10px'}}>
                                Select actions to randomly apply during animation. Eye selections include eyebrows for full expression control!
                            </p>
                            <div className="btn-row">
                                <button
                                    className={`btn ${eyePresets.includes('blink') ? 'btn-primary' : ''}`}
                                    onClick={() => toggleEyePreset('blink')}
                                >
                                    Blink
                                </button>
                                <button
                                    className={`btn ${eyePresets.includes('wink_left') ? 'btn-primary' : ''}`}
                                    onClick={() => toggleEyePreset('wink_left')}
                                >
                                    Wink Left
                                </button>
                                <button
                                    className={`btn ${eyePresets.includes('wink_right') ? 'btn-primary' : ''}`}
                                    onClick={() => toggleEyePreset('wink_right')}
                                >
                                    Wink Right
                                </button>
                            </div>
                            <div className="btn-row">
                                <button
                                    className={`btn ${eyePresets.includes('excited') ? 'btn-primary' : ''}`}
                                    onClick={() => toggleEyePreset('excited')}
                                >
                                    Excited
                                </button>
                                <button
                                    className={`btn ${eyePresets.includes('glare') ? 'btn-primary' : ''}`}
                                    onClick={() => toggleEyePreset('glare')}
                                >
                                    Glare
                                </button>
                            </div>
                            <div className="btn-row">
                                <button
                                    className={`btn ${eyePresets.includes('look_left') ? 'btn-primary' : ''}`}
                                    onClick={() => toggleEyePreset('look_left')}
                                >
                                    Look Left
                                </button>
                                <button
                                    className={`btn ${eyePresets.includes('look_right') ? 'btn-primary' : ''}`}
                                    onClick={() => toggleEyePreset('look_right')}
                                >
                                    Look Right
                                </button>
                            </div>
                            <div className="btn-row">
                                <button
                                    className={`btn ${eyePresets.includes('look_up') ? 'btn-primary' : ''}`}
                                    onClick={() => toggleEyePreset('look_up')}
                                >
                                    Look Up
                                </button>
                                <button
                                    className={`btn ${eyePresets.includes('look_down') ? 'btn-primary' : ''}`}
                                    onClick={() => toggleEyePreset('look_down')}
                                >
                                    Look Down
                                </button>
                            </div>
                            <div className="btn-row">
                                <button
                                    className={`btn ${eyePresets.includes('eye_roll') ? 'btn-primary' : ''}`}
                                    onClick={() => toggleEyePreset('eye_roll')}
                                >
                                    Eye Roll
                                </button>
                            </div>
                        </div>

                        <div className="panel">
                            <h3>Drafts</h3>
                            <div className="btn-row">
                                <button className="btn" onClick={saveDraft}>Save Draft</button>
                                <button className="btn btn-danger" onClick={clearDraft}>Clear Draft</button>
                            </div>
                        </div>

                        <div className="panel">
                            <h3>Export Options</h3>
                            <label style={{display: 'flex', alignItems: 'center', gap: 8, cursor: 'pointer', marginBottom: 8}}>
                                <input
                                    type="checkbox"
                                    checked={exportWithAudio}
                                    onChange={e => setExportWithAudio(e.target.checked)}
                                    style={{accentColor: 'var(--accent)'}}
                                />
                                <span style={{fontSize: '0.85rem'}}>Include Audio</span>
                            </label>
                            <label style={{display: 'flex', alignItems: 'center', gap: 8, cursor: 'pointer'}}>
                                <input
                                    type="checkbox"
                                    checked={exportWithBackground}
                                    onChange={e => setExportWithBackground(e.target.checked)}
                                    style={{accentColor: 'var(--accent)'}}
                                />
                                <span style={{fontSize: '0.85rem'}}>Include Background</span>
                            </label>
                            {!exportWithAudio && (
                                <p style={{fontSize: '0.7rem', color: '#888', marginTop: 8}}>
                                    Video will be exported without sound.
                                </p>
                            )}
                            {!exportWithBackground && bgRemovalEnabled && (
                                <p style={{fontSize: '0.7rem', color: '#888', marginTop: 8}}>
                                    Character will be exported on transparent/black background.
                                </p>
                            )}
                        </div>

                        {!isAnimating ? (
                            <button className="btn btn-primary" style={{padding:15, fontSize:'1.1em'}} onClick={startAnimation} disabled={polyPoints.length < 3}>Animate & Record</button>
                        ) : (
                            <button className="btn btn-danger" style={{padding:15, fontSize:'1.1em'}} onClick={stopEverything}>Stop</button>
                        )}

                        <div style={{textAlign:'center', color:'#666', fontSize:'0.8rem'}}>{status}</div>

                        {recordedVideo && (
                            <div className="panel" style={{textAlign:'center', borderColor:'#00ff99'}}>
                                <h3 style={{color:'#00ff99', margin:0}}>Result Ready</h3>
                                <video controls src={recordedVideo} style={{width:'100%', marginTop:10, borderRadius:4}} />
                                <a href={recordedVideo} download="lipsync_3d.webm" className="btn btn-primary" style={{display:'block', marginTop:10, textDecoration:'none'}}>Download</a>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lip Sync Pro - 3D Anatomy</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@vladmandic/face-api/dist/face-api.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js" crossorigin="anonymous"></script>
    <style>
        :root { --accent: #ff00ff; --bg: #080808; --panel: #141414; --text: #ccc; }
        body { font-family: 'Segoe UI', system-ui, sans-serif; background: var(--bg); color: var(--text); margin: 0; padding: 20px; height: 100vh; overflow: hidden; }
        .layout { display: grid; grid-template-columns: 1fr 380px; gap: 20px; height: 95vh; max-width: 1900px; margin: 0 auto; }
        
        .stage { background: #000; border-radius: 12px; border: 1px solid #333; display: flex; align-items: center; justify-content: center; position: relative; overflow: hidden; }
        canvas { max-width: 100%; max-height: 100%; object-fit: contain; filter: drop-shadow(0 0 50px rgba(0,0,0,0.5)); }
        
        .controls { background: var(--panel); padding: 25px; border-radius: 12px; border: 1px solid #333; overflow-y: auto; display: flex; flex-direction: column; gap: 18px; }
        
        h1 { font-size: 1.4rem; color: #fff; margin: 0 0 5px 0; border-bottom: 2px solid var(--accent); display: inline-block; padding-bottom: 8px; letter-spacing: 1px; }
        h3 { font-size: 0.85rem; text-transform: uppercase; color: #666; margin: 5px 0 10px 0; font-weight: 700; letter-spacing: 0.5px; }

        .panel { background: #1f1f1f; padding: 16px; border-radius: 8px; border: 1px solid #2a2a2a; }
        
        .slider-row { display: flex; align-items: center; gap: 12px; margin-bottom: 12px; }
        .slider-row label { font-size: 0.8rem; width: 110px; color: #aaa; font-weight: 500; }
        input[type=range] { flex: 1; accent-color: var(--accent); height: 4px; background: #444; border-radius: 2px; cursor: pointer; }
        
        .btn-row { display: flex; gap: 10px; flex-wrap: wrap; }
        .btn { flex: 1; padding: 12px; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; transition: 0.2s; background: #2a2a2a; color: #fff; font-size: 0.85rem; text-transform: uppercase; min-width: 80px; }
        .btn:hover { background: #333; color: var(--accent); }
        .btn-primary { background: var(--accent); color: #fff; }
        .btn-primary:hover { background: #d600d6; color: #fff; }
        .btn-danger { background: #d32f2f; color: #fff; }
        .btn:disabled { opacity: 0.4; cursor: not-allowed; }

        .tabs { display: flex; background: #222; padding: 4px; border-radius: 6px; margin-bottom: 15px; }
        .tab { flex: 1; text-align: center; padding: 8px; font-size: 0.85rem; cursor: pointer; color: #888; border-radius: 4px; transition: 0.2s; font-weight: 600; }
        .tab.active { background: #333; color: #fff; }

        .upload-zone { border: 2px dashed #444; padding: 40px; text-align: center; border-radius: 8px; cursor: pointer; transition: 0.2s; color: #666; }
        .upload-zone:hover { border-color: var(--accent); color: #fff; background: #111; }

        .overlay-msg { position: absolute; background: rgba(0,0,0,0.9); padding: 20px; border-radius: 12px; display: flex; flex-direction: column; align-items: center; z-index: 20; color: #fff; }
        .spinner { width: 30px; height: 30px; border: 3px solid #333; border-top-color: var(--accent); border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 10px; }
        @keyframes spin { to { transform: rotate(360deg); } }
        
        .hint { font-size: 0.75rem; color: #666; margin-top: 5px; text-align: center; font-style: italic; }

        /* Added for UI refinement */
        @media (max-width: 1200px) {
            .layout { grid-template-columns: 1fr; }
            .controls { order: 1; max-height: 40vh; }
            .stage { order: 2; height: 50vh; }
        }
        .btn:focus { outline: 2px solid var(--accent); outline-offset: 2px; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const App = () => {
            const [image, setImage] = React.useState(null);
            const [status, setStatus] = React.useState("Ready");
            const [modelsLoaded, setModelsLoaded] = React.useState(false);
            const [isDetecting, setIsDetecting] = React.useState(false);
            
            // Vector Mask for mouth
            const [polyPoints, setPolyPoints] = React.useState([]); 
            const [draggedPointIndex, setDraggedPointIndex] = React.useState(null);
            
            // Manual Draw mode (replaces Manual Box)
            const [manualDrawMode, setManualDrawMode] = React.useState(false);
            const [manualDrawFeature, setManualDrawFeature] = React.useState('mouth');
            const [drawingPoints, setDrawingPoints] = React.useState([]);

            const [isDraggingPoly, setIsDraggingPoly] = React.useState(false);
            const polyDragStartRef = React.useRef(null);
            const polyDragOrigRef = React.useRef(null);

            // Eyes (includes eyebrows for full expression control)
            const [leftEyePoints, setLeftEyePoints] = React.useState([]);
            const [rightEyePoints, setRightEyePoints] = React.useState([]);
            const [eyePresets, setEyePresets] = React.useState(['blink', 'wink_left', 'look_left', 'look_right']); // Selected eye presets to apply randomly
            const [draggedEye, setDraggedEye] = React.useState(null); // 'left', 'right'

            // Lip line (editable line following the split between upper and lower lips)
            const [lipLinePoints, setLipLinePoints] = React.useState([]);

            // Zoom/Magnification for fine-tuning
            const [isZoomed, setIsZoomed] = React.useState(false);
            const [zoomScale, setZoomScale] = React.useState(1.0); // Start at 1.0 (no zoom)
            const [panOffset, setPanOffset] = React.useState({ x: 0, y: 0 });
            const [isPanning, setIsPanning] = React.useState(false);
            const panStartRef = React.useRef(null);
            const panOffsetStartRef = React.useRef(null);
            const zoomOutHoldTimerRef = React.useRef(null);

            // Feature toggles
            const [enableMouth, setEnableMouth] = React.useState(true);
            const [enableEyes, setEnableEyes] = React.useState(true);

            // Undo/Redo system
            const [history, setHistory] = React.useState([]);
            const [historyIndex, setHistoryIndex] = React.useState(-1);

            // Interaction
            const [activeTab, setActiveTab] = React.useState('audio');
            const [isAnimating, setIsAnimating] = React.useState(false);
            const [recordedVideo, setRecordedVideo] = React.useState(null);

            const [audioUrl, setAudioUrl] = React.useState(null);
            const [text, setText] = React.useState("Notice the 3D shape of the teeth and the bottom molars.");
            const [voices, setVoices] = React.useState([]);

            // Voice Recording
            const [isRecordingVoice, setIsRecordingVoice] = React.useState(false);
            const voiceRecorderRef = React.useRef(null);
            const voiceChunksRef = React.useRef([]);

            // Custom Voice Profile Controls
            const [voiceGender, setVoiceGender] = React.useState('male');
            const [voiceRate, setVoiceRate] = React.useState(0.95); // Speed: 0.1 to 2 (radio announcer slightly slower)
            const [voicePitch, setVoicePitch] = React.useState(0.9); // 0 to 2 (deeper pitch for male announcer)
            const [voiceVolume, setVoiceVolume] = React.useState(1.0); // 0 to 1
            const [voiceTimbre, setVoiceTimbre] = React.useState('warm'); // warm, neutral, bright
            const [voiceAccent, setVoiceAccent] = React.useState('neutral'); // neutral, british, american, australian
            const [savedVoiceProfiles, setSavedVoiceProfiles] = React.useState([]);

            // Params
            const [lipSplit, setLipSplit] = React.useState(0.5);
            const [lipWidth, setLipWidth] = React.useState(0.85);
            const [cupidBow, setCupidBow] = React.useState(0.3);
            const [lipCurve, setLipCurve] = React.useState(0.1);
            
            // 3D Anatomy Params
            const [teethBrightness, setTeethBrightness] = React.useState(0.9);
            const [teethShade, setTeethShade] = React.useState(0.2); // 0=White, 1=Yellow
            const [teethVertical, setTeethVertical] = React.useState(0);
            const [jawGap, setJawGap] = React.useState(0.1); // Spacing between top/bottom teeth
            const [tongueHeight, setTongueHeight] = React.useState(0.8); // Allowed to go higher
            const [lipLighten, setLipLighten] = React.useState(0.5);
            
            
            const [splitColor, setSplitColor] = React.useState(0.35);
            const [splitTexture, setSplitTexture] = React.useState(0.35);
            const [lipRoll, setLipRoll] = React.useState(0.35);
            const [syllableSnap, setSyllableSnap] = React.useState(0.5);
            const [sensitivity, setSensitivity] = React.useState(1.5);
            const [smoothing, setSmoothing] = React.useState(0.2);

            // Background Removal
            const [bgRemovalEnabled, setBgRemovalEnabled] = React.useState(false);
            const [bgRemovalThreshold, setBgRemovalThreshold] = React.useState(0.5);
            const [bgRemovalEdge, setBgRemovalEdge] = React.useState(0.1);
            const [isRemovingBg, setIsRemovingBg] = React.useState(false);

            // Background/Video
            const [backgroundType, setBackgroundType] = React.useState('none'); // 'none', 'color', 'image', 'video'
            const [backgroundColor, setBackgroundColor] = React.useState('#000000');
            const [backgroundImage, setBackgroundImage] = React.useState(null);
            const [backgroundVideo, setBackgroundVideo] = React.useState(null);

            // Character positioning on background
            const [characterPosition, setCharacterPosition] = React.useState({ x: 0.5, y: 0.5, scale: 1.0 });
            const [isDraggingCharacter, setIsDraggingCharacter] = React.useState(false);

            // Audio source selection
            const [audioSource, setAudioSource] = React.useState('file'); // 'none', 'file', 'record', 'tts', 'video'

            // Export options
            const [exportWithAudio, setExportWithAudio] = React.useState(true);
            const [exportWithBackground, setExportWithBackground] = React.useState(true);

            const canvasRef = React.useRef(null);
            const imageRef = React.useRef(null);
            const audioRef = React.useRef(null);
            const animationFrameRef = React.useRef(null);
            const originalImageDataRef = React.useRef(null);
            const characterMaskRef = React.useRef(null); // Stores the segmented character with transparency
            const mouthTextureRef = React.useRef(null);
            const audioContextRef = React.useRef(null);
            const mediaRecorderRef = React.useRef(null);
            const chunksRef = React.useRef([]);
            const backgroundVideoRef = React.useRef(null);
            const segmenterRef = React.useRef(null);

            const params = React.useRef({});

            const draftKey = 'lipSyncDraft';

            const getBounds = (points) => {
                if(!points || points.length === 0) return {x:0,y:0,width:0,height:0};
                let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
                points.forEach(p => {
                    if(p.x < minX) minX = p.x; if(p.x > maxX) maxX = p.x;
                    if(p.y < minY) minY = p.y; if(p.y > maxY) maxY = p.y;
                });
                return { x: Math.floor(minX), y: Math.floor(minY), width: Math.ceil(maxX - minX), height: Math.ceil(maxY - minY) };
            };

            // --- UNDO/REDO SYSTEM ---
            const saveToHistory = () => {
                const state = {
                    polyPoints: JSON.parse(JSON.stringify(polyPoints)),
                    leftEyePoints: JSON.parse(JSON.stringify(leftEyePoints)),
                    rightEyePoints: JSON.parse(JSON.stringify(rightEyePoints))
                };

                // Truncate history if we're not at the end
                const newHistory = history.slice(0, historyIndex + 1);
                newHistory.push(state);

                // Keep only last 15 states
                if (newHistory.length > 15) {
                    newHistory.shift();
                }

                setHistory(newHistory);
                setHistoryIndex(newHistory.length - 1);

                // Save to localStorage
                try {
                    localStorage.setItem('lipSyncHistory', JSON.stringify(newHistory));
                } catch (e) {
                    console.error('Failed to save history to localStorage:', e);
                }
            };

            const undo = () => {
                if (historyIndex > 0) {
                    const prevIndex = historyIndex - 1;
                    const state = history[prevIndex];
                    setPolyPoints(state.polyPoints);
                    setLeftEyePoints(state.leftEyePoints);
                    setRightEyePoints(state.rightEyePoints);
                    setHistoryIndex(prevIndex);
                }
            };

            const redo = () => {
                if (historyIndex < history.length - 1) {
                    const nextIndex = historyIndex + 1;
                    const state = history[nextIndex];
                    setPolyPoints(state.polyPoints);
                    setLeftEyePoints(state.leftEyePoints);
                    setRightEyePoints(state.rightEyePoints);
                    setHistoryIndex(nextIndex);
                }
            };

            // --- BACKGROUND REMOVAL ---
            const initSegmenter = async () => {
                if (segmenterRef.current) return segmenterRef.current;

                try {
                    const segmenter = new SelfieSegmentation({
                        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}`
                    });
                    segmenter.setOptions({ modelSelection: 1, selfieMode: false });
                    await segmenter.initialize();
                    segmenterRef.current = segmenter;
                    return segmenter;
                } catch (e) {
                    console.error('Failed to initialize segmenter:', e);
                    return null;
                }
            };

            const removeBackground = async () => {
                if (!image || !canvasRef.current) return;

                setIsRemovingBg(true);
                setStatus('Removing background...');

                try {
                    const segmenter = await initSegmenter();
                    if (!segmenter) {
                        setStatus('Background removal not available');
                        setIsRemovingBg(false);
                        return;
                    }

                    // Create a temporary canvas with the original image
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = canvasRef.current.width;
                    tempCanvas.height = canvasRef.current.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    if (originalImageDataRef.current) {
                        tempCtx.putImageData(originalImageDataRef.current, 0, 0);
                    }

                    // Run segmentation
                    const results = await new Promise((resolve) => {
                        segmenter.onResults(resolve);
                        segmenter.send({ image: tempCanvas });
                    });

                    if (results.segmentationMask) {
                        // Create character mask with transparency
                        const maskCanvas = document.createElement('canvas');
                        maskCanvas.width = tempCanvas.width;
                        maskCanvas.height = tempCanvas.height;
                        const maskCtx = maskCanvas.getContext('2d');

                        // Draw the original image
                        maskCtx.drawImage(tempCanvas, 0, 0);

                        // Get the image data
                        const imageData = maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height);
                        const maskData = results.segmentationMask;

                        // Create a temporary canvas to read the mask
                        const maskReadCanvas = document.createElement('canvas');
                        maskReadCanvas.width = maskCanvas.width;
                        maskReadCanvas.height = maskCanvas.height;
                        const maskReadCtx = maskReadCanvas.getContext('2d');
                        maskReadCtx.drawImage(maskData, 0, 0, maskCanvas.width, maskCanvas.height);
                        const maskPixels = maskReadCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height).data;

                        // Apply mask with threshold and edge softening
                        for (let i = 0; i < imageData.data.length; i += 4) {
                            const maskValue = maskPixels[i] / 255; // 0-1

                            // Apply threshold
                            let alpha;
                            if (maskValue > bgRemovalThreshold + bgRemovalEdge) {
                                alpha = 255;
                            } else if (maskValue < bgRemovalThreshold - bgRemovalEdge) {
                                alpha = 0;
                            } else {
                                // Smooth edge transition
                                alpha = Math.round(((maskValue - (bgRemovalThreshold - bgRemovalEdge)) / (bgRemovalEdge * 2)) * 255);
                            }

                            imageData.data[i + 3] = alpha;
                        }

                        maskCtx.putImageData(imageData, 0, 0);
                        characterMaskRef.current = maskCanvas;
                        setBgRemovalEnabled(true);
                        setStatus('Background removed. Adjust threshold/edge if needed.');
                        drawOverlay();
                    }
                } catch (e) {
                    console.error('Background removal failed:', e);
                    setStatus('Background removal failed: ' + e.message);
                }

                setIsRemovingBg(false);
            };

            const resetBackgroundRemoval = () => {
                characterMaskRef.current = null;
                setBgRemovalEnabled(false);
                drawOverlay();
            };

            // --- BACKGROUND IMAGE/VIDEO LOADING ---
            const handleBackgroundImageUpload = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (ev) => {
                    const img = new Image();
                    img.onload = () => {
                        setBackgroundImage(img);
                        setBackgroundType('image');
                        setStatus('Background image loaded');
                        drawOverlay();
                    };
                    img.src = ev.target.result;
                };
                reader.readAsDataURL(file);
            };

            const handleBackgroundVideoUpload = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const videoUrl = URL.createObjectURL(file);
                const video = document.createElement('video');
                video.src = videoUrl;
                video.muted = true;
                video.loop = true;
                video.preload = 'auto';

                video.onloadedmetadata = () => {
                    setBackgroundVideo(video);
                    backgroundVideoRef.current = video;
                    setBackgroundType('video');
                    setStatus('Background video loaded');

                    // Also extract audio from video if audio source is 'video'
                    if (audioSource === 'video') {
                        const audioVideo = document.createElement('video');
                        audioVideo.src = videoUrl;
                        audioVideo.preload = 'auto';
                        setAudioUrl(videoUrl);
                    }

                    video.play().catch(() => {});
                    drawOverlay();
                };
                video.load();
            };

            const clearBackground = () => {
                if (backgroundVideoRef.current) {
                    backgroundVideoRef.current.pause();
                    backgroundVideoRef.current.src = '';
                }
                setBackgroundImage(null);
                setBackgroundVideo(null);
                setBackgroundType('none');
                backgroundVideoRef.current = null;
                drawOverlay();
            };

            // Load history from localStorage on mount
            React.useEffect(() => {
                try {
                    const savedHistory = localStorage.getItem('lipSyncHistory');
                    if (savedHistory) {
                        const parsed = JSON.parse(savedHistory);
                        setHistory(parsed);
                        setHistoryIndex(parsed.length - 1);
                    }
                } catch (e) {
                    console.error('Failed to load history from localStorage:', e);
                }
            }, []);

            React.useEffect(() => {
                params.current = { lipSplit, lipWidth, cupidBow, lipCurve, teethBrightness, teethShade, teethVertical, jawGap, tongueHeight, lipLighten, splitColor, splitTexture, sensitivity, smoothing, lipRoll, syllableSnap };
                if (polyPoints.length > 2 && !isAnimating) {
                    const bounds = getBounds(polyPoints);
                    generateMouthTexture(bounds.width, bounds.height);
                    drawOverlay();
                }
            }, [lipSplit, lipWidth, cupidBow, lipCurve, teethBrightness, teethShade, teethVertical, jawGap, tongueHeight, lipLighten, splitColor, splitTexture, sensitivity, smoothing, lipRoll, syllableSnap, polyPoints, leftEyePoints, rightEyePoints, isZoomed, zoomScale, panOffset]);

            React.useEffect(() => {
                const init = async () => {
                    try {
                        const URL = 'https://cdn.jsdelivr.net/npm/@vladmandic/face-api/model';
                        await Promise.all([
                            faceapi.nets.tinyFaceDetector.loadFromUri(URL),
                            faceapi.nets.faceLandmark68Net.loadFromUri(URL)
                        ]);
                        setModelsLoaded(true);
                    } catch(e) { setStatus("AI Failed. Use Manual."); }
                    const getVoices = () => setVoices(window.speechSynthesis.getVoices());
                    getVoices(); window.speechSynthesis.onvoiceschanged = getVoices;
                };
                init();
                return () => stopEverything();
            }, []);

            // Load draft on mount
            React.useEffect(() => {
                const saved = localStorage.getItem(draftKey);
                if (saved) {
                    const data = JSON.parse(saved);
                    setLipSplit(data.lipSplit || 0.5);
                    setLipWidth(data.lipWidth || 0.85);
                    setCupidBow(data.cupidBow || 0.3);
                    setLipCurve(data.lipCurve || 0.1);
                    setTeethBrightness(data.teethBrightness || 0.9);
                    setTeethShade(data.teethShade || 0.2);
                    setTeethVertical(data.teethVertical || 0);
                    setJawGap(data.jawGap || 0.1);
                    setTongueHeight(data.tongueHeight || 0.8);
                    setLipLighten(data.lipLighten || 0.5);
                    setSplitColor(data.splitColor || 0.35);
                    setSplitTexture(data.splitTexture || 0.35);
                    setLipRoll(data.lipRoll || 0.35);
                    setSyllableSnap(data.syllableSnap || 0.5);
                    setSensitivity(data.sensitivity || 1.5);
                    setSmoothing(data.smoothing || 0.2);
                    setPolyPoints(data.polyPoints || []);
                    setLeftEyePoints(data.leftEyePoints || []);
                    setRightEyePoints(data.rightEyePoints || []);
                    setEyePresets(data.eyePresets || ['blink', 'wink_left', 'look_left', 'look_right']);
                    setVoiceGender(data.voiceGender || 'male');
                    setVoiceRate(data.voiceRate || 0.95);
                    setVoicePitch(data.voicePitch || 0.9);
                    setVoiceVolume(data.voiceVolume || 1.0);
                    setVoiceTimbre(data.voiceTimbre || 'warm');
                    setVoiceAccent(data.voiceAccent || 'neutral');
                    setSavedVoiceProfiles(data.savedVoiceProfiles || []);
                    setText(data.text || "Notice the 3D shape of the teeth and the bottom molars.");
                    // AudioUrl and image not saved as they are large/blobs
                }
            }, []);

            const saveDraft = () => {
                const data = {
                    lipSplit, lipWidth, cupidBow, lipCurve, teethBrightness, teethShade, teethVertical, jawGap, tongueHeight, lipLighten,
                    splitColor, splitTexture, lipRoll, syllableSnap, sensitivity, smoothing,
                    polyPoints, leftEyePoints, rightEyePoints,
                    eyePresets, voiceGender, voiceRate, voicePitch, voiceVolume, voiceTimbre, voiceAccent, savedVoiceProfiles, text
                };
                localStorage.setItem(draftKey, JSON.stringify(data));
                setStatus("Draft saved!");
            };

            const clearDraft = () => {
                localStorage.removeItem(draftKey);
                setStatus("Draft cleared.");
            };

            // Voice Profile Management
            const saveVoiceProfile = (profileName) => {
                if (!profileName || profileName.trim() === '') {
                    setStatus("Please enter a profile name");
                    return;
                }

                const profile = {
                    name: profileName.trim(),
                    gender: voiceGender,
                    rate: voiceRate,
                    pitch: voicePitch,
                    volume: voiceVolume,
                    timbre: voiceTimbre,
                    accent: voiceAccent,
                    timestamp: Date.now()
                };

                const updatedProfiles = [...savedVoiceProfiles.filter(p => p.name !== profileName.trim()), profile];
                setSavedVoiceProfiles(updatedProfiles);
                setStatus(`Voice profile "${profileName}" saved!`);

                // Also save to draft
                saveDraft();
            };

            const loadVoiceProfile = (profile) => {
                setVoiceGender(profile.gender);
                setVoiceRate(profile.rate);
                setVoicePitch(profile.pitch);
                setVoiceVolume(profile.volume);
                setVoiceTimbre(profile.timbre);
                setVoiceAccent(profile.accent);
                setStatus(`Voice profile "${profile.name}" loaded!`);
            };

            const deleteVoiceProfile = (profileName) => {
                setSavedVoiceProfiles(savedVoiceProfiles.filter(p => p.name !== profileName));
                setStatus(`Voice profile "${profileName}" deleted!`);
            };

            const exportVoiceProfile = (profile) => {
                const dataStr = JSON.stringify(profile, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `voice-profile-${profile.name}.json`;
                link.click();
                URL.revokeObjectURL(url);
                setStatus(`Voice profile "${profile.name}" exported!`);
            };

            const importVoiceProfile = (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const profile = JSON.parse(e.target.result);
                        if (profile.name && profile.gender && profile.rate !== undefined) {
                            const updatedProfiles = [...savedVoiceProfiles.filter(p => p.name !== profile.name), profile];
                            setSavedVoiceProfiles(updatedProfiles);
                            setStatus(`Voice profile "${profile.name}" imported!`);
                        } else {
                            setStatus("Invalid voice profile file");
                        }
                    } catch (err) {
                        setStatus("Error reading voice profile file");
                    }
                };
                reader.readAsText(file);
            };

            // Voice Recording
            const startVoiceRecord = async () => {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    const recorder = new MediaRecorder(stream);
                    voiceRecorderRef.current = recorder;
                    voiceChunksRef.current = [];
                    recorder.ondataavailable = (e) => voiceChunksRef.current.push(e.data);
                    recorder.onstop = () => {
                        const blob = new Blob(voiceChunksRef.current, { type: 'audio/webm' });
                        setAudioUrl(URL.createObjectURL(blob));
                        setStatus("Voice recorded!");
                    };
                    recorder.start();
                    setIsRecordingVoice(true);
                } catch (e) {
                    setStatus("Microphone access denied.");
                    console.error(e);
                }
            };

            const stopVoiceRecord = () => {
                if (voiceRecorderRef.current) {
                    voiceRecorderRef.current.stop();
                    setIsRecordingVoice(false);
                }
            };

            // --- INTERACTION ---
            const getCoords = (e) => {
                const rect = canvasRef.current.getBoundingClientRect();
                const scaleX = canvasRef.current.width / rect.width;
                const scaleY = canvasRef.current.height / rect.height;

                let canvasX, canvasY;

                // Handle touch events
                if (e.touches && e.touches.length > 0) {
                    canvasX = (e.touches[0].clientX - rect.left) * scaleX;
                    canvasY = (e.touches[0].clientY - rect.top) * scaleY;
                } else {
                    canvasX = (e.clientX - rect.left) * scaleX;
                    canvasY = (e.clientY - rect.top) * scaleY;
                }

                // If zoomed, transform coordinates back to original image space
                if (isZoomed && zoomScale > 1.0) {
                    const imageWidth = canvasRef.current.width;
                    const imageHeight = canvasRef.current.height;

                    // Calculate the zoomed viewport dimensions
                    const viewportWidth = imageWidth / zoomScale;
                    const viewportHeight = imageHeight / zoomScale;

                    // Transform canvas coordinates to image coordinates
                    const imageX = (canvasX / imageWidth) * viewportWidth + panOffset.x;
                    const imageY = (canvasY / imageHeight) * viewportHeight + panOffset.y;

                    return { x: imageX, y: imageY };
                }

                return { x: canvasX, y: canvasY };
            };

            const isNearPoint = (p, target, radius=20) => Math.sqrt(Math.pow(p.x - target.x, 2) + Math.pow(p.y - target.y, 2)) < radius;

            const distToSegment = (p, a, b) => {
                const l2 = Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2);
                if (l2 === 0) return Math.sqrt(Math.pow(p.x - a.x, 2) + Math.pow(p.y - a.y, 2));
                let t = ((p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y)) / l2;
                t = Math.max(0, Math.min(1, t));
                const proj = { x: a.x + t * (b.x - a.x), y: a.y + t * (b.y - a.y) };
                return Math.sqrt(Math.pow(p.x - proj.x, 2) + Math.pow(p.y - proj.y, 2));
            };

            const pointInPoly = (pt, poly) => {
                if (!poly || poly.length < 3) return false;
                let inside = false;
                for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
                    const xi = poly[i].x, yi = poly[i].y;
                    const xj = poly[j].x, yj = poly[j].y;
                    const intersect = ((yi > pt.y) !== (yj > pt.y)) &&
                        (pt.x < (xj - xi) * (pt.y - yi) / ((yj - yi) || 1e-9) + xi);
                    if (intersect) inside = !inside;
                }
                return inside;
            };

            const findClickedPolygon = (point) => {
                // Check which polygon (if any) was clicked
                // Returns {type: 'mouth'|'leftEye'|'rightEye', points: array, pointIndex: number}

                // Check mouth points
                const mouthIdx = polyPoints.findIndex(p => isNearPoint(p, point));
                if (mouthIdx !== -1) return { type: 'mouth', points: polyPoints, pointIndex: mouthIdx };

                // Check left eye points (includes eyebrows)
                const leftEyeIdx = leftEyePoints.findIndex(p => isNearPoint(p, point));
                if (leftEyeIdx !== -1) return { type: 'leftEye', points: leftEyePoints, pointIndex: leftEyeIdx };

                // Check right eye points (includes eyebrows)
                const rightEyeIdx = rightEyePoints.findIndex(p => isNearPoint(p, point));
                if (rightEyeIdx !== -1) return { type: 'rightEye', points: rightEyePoints, pointIndex: rightEyeIdx };

                // Check if inside polygons (for dragging whole polygon)
                if (polyPoints.length > 2 && pointInPoly(point, polyPoints)) return { type: 'mouth', points: polyPoints, pointIndex: -1 };
                if (leftEyePoints.length > 2 && pointInPoly(point, leftEyePoints)) return { type: 'leftEye', points: leftEyePoints, pointIndex: -1 };
                if (rightEyePoints.length > 2 && pointInPoly(point, rightEyePoints)) return { type: 'rightEye', points: rightEyePoints, pointIndex: -1 };

                return null;
            };

            const updatePolygon = (type, newPoints) => {
                if (type === 'mouth') setPolyPoints(newPoints);
                else if (type === 'leftEye') setLeftEyePoints(newPoints);
                else if (type === 'rightEye') setRightEyePoints(newPoints);
            };

            const handleMouseDown = (e) => {
                if (isAnimating || !image) return;

                // For manual draw mode, place anchor points on click
                if (manualDrawMode) {
                    const m = getCoords(e);

                    // Check if clicking near the first point to close the loop
                    if (drawingPoints.length >= 3 && isNearPoint(m, drawingPoints[0], 15)) {
                        // Close the loop - apply the points to the selected feature
                        const newPoints = [...drawingPoints];
                        updatePolygon(manualDrawFeature, newPoints);
                        setDrawingPoints([]);
                        setManualDrawMode(false);
                        setStatus(`${manualDrawFeature} shape applied. Refine points or start animation.`);
                        saveToHistory();
                        drawOverlay();
                        return;
                    }

                    // Add a new anchor point
                    const newPoints = [...drawingPoints, m];
                    setDrawingPoints(newPoints);
                    drawOverlay();
                    return;
                }

                const m = getCoords(e);
                const clicked = findClickedPolygon(m);

                // If zoomed in
                if (isZoomed && zoomScale > 1.0) {
                    if (clicked) {
                        if (clicked.pointIndex !== -1) {
                            // Clicked on a point - allow dragging while zoomed (don't zoom out)
                            setDraggedPointIndex(clicked.pointIndex);
                            setDraggedEye(clicked.type);
                        } else {
                            // Clicked inside polygon - start hold timer to begin dragging at 50% speed
                            zoomOutHoldTimerRef.current = setTimeout(() => {
                                // Start dragging the polygon while staying zoomed (movement will be 50% speed)
                                setIsDraggingPoly(true);
                                setDraggedEye(clicked.type);
                                polyDragStartRef.current = m;
                                polyDragOrigRef.current = clicked.points.map(p => ({ ...p }));
                            }, 200); // Short hold to distinguish from accidental clicks
                        }
                    } else {
                        // Start panning
                        setIsPanning(true);
                        const rect = canvasRef.current.getBoundingClientRect();
                        const scaleX = canvasRef.current.width / rect.width;
                        const scaleY = canvasRef.current.height / rect.height;
                        if (e.touches && e.touches.length > 0) {
                            panStartRef.current = {
                                x: (e.touches[0].clientX - rect.left) * scaleX,
                                y: (e.touches[0].clientY - rect.top) * scaleY
                            };
                        } else {
                            panStartRef.current = {
                                x: (e.clientX - rect.left) * scaleX,
                                y: (e.clientY - rect.top) * scaleY
                            };
                        }
                        panOffsetStartRef.current = { ...panOffset };
                    }
                    return;
                }

                // Normal mode (not zoomed) - allow dragging
                if (!clicked) return;

                if (clicked.pointIndex !== -1) {
                    // Clicked on a point
                    setDraggedPointIndex(clicked.pointIndex);
                    setDraggedEye(clicked.type);
                } else {
                    // Clicked inside polygon (drag whole polygon)
                    setIsDraggingPoly(true);
                    setDraggedEye(clicked.type);
                    polyDragStartRef.current = m;
                    polyDragOrigRef.current = clicked.points.map(p => ({ ...p }));
                }
            };

            const handleMouseMove = (e) => {
                if (!image) return;

                // Clear zoom-out hold timer if mouse moves (user is panning/dragging, not holding)
                if (zoomOutHoldTimerRef.current) {
                    clearTimeout(zoomOutHoldTimerRef.current);
                    zoomOutHoldTimerRef.current = null;
                }

                // Handle panning when zoomed
                if (isPanning && panStartRef.current && panOffsetStartRef.current) {
                    const rect = canvasRef.current.getBoundingClientRect();
                    const scaleX = canvasRef.current.width / rect.width;
                    const scaleY = canvasRef.current.height / rect.height;

                    let currentX, currentY;
                    if (e.touches && e.touches.length > 0) {
                        currentX = (e.touches[0].clientX - rect.left) * scaleX;
                        currentY = (e.touches[0].clientY - rect.top) * scaleY;
                    } else {
                        currentX = (e.clientX - rect.left) * scaleX;
                        currentY = (e.clientY - rect.top) * scaleY;
                    }

                    const dx = currentX - panStartRef.current.x;
                    const dy = currentY - panStartRef.current.y;

                    const imageWidth = canvasRef.current.width;
                    const imageHeight = canvasRef.current.height;
                    const viewportWidth = imageWidth / zoomScale;
                    const viewportHeight = imageHeight / zoomScale;

                    // Convert canvas pixel movement to image space movement
                    const imageDx = (dx / imageWidth) * viewportWidth;
                    const imageDy = (dy / imageHeight) * viewportHeight;

                    let newPanX = panOffsetStartRef.current.x - imageDx;
                    let newPanY = panOffsetStartRef.current.y - imageDy;

                    // Clamp pan offset to keep image within bounds
                    newPanX = Math.max(0, Math.min(imageWidth - viewportWidth, newPanX));
                    newPanY = Math.max(0, Math.min(imageHeight - viewportHeight, newPanY));

                    setPanOffset({ x: newPanX, y: newPanY });
                    drawOverlay();
                    return;
                }

                const m = getCoords(e);

                // Manual draw mode - update cursor and draw preview line
                if (manualDrawMode && drawingPoints.length > 0) {
                    // Draw preview line from last point to current mouse position
                    drawOverlay();
                    const ctx = canvasRef.current.getContext('2d');
                    const lastPt = transformPointToCanvas(drawingPoints[drawingPoints.length - 1]);
                    const currentPt = transformPointToCanvas(m);
                    ctx.strokeStyle = '#00ff99';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([6, 4]);
                    ctx.beginPath();
                    ctx.moveTo(lastPt.x, lastPt.y);
                    ctx.lineTo(currentPt.x, currentPt.y);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Highlight first point if near it (to indicate loop closure)
                    if (drawingPoints.length >= 3 && isNearPoint(m, drawingPoints[0], 15)) {
                        const firstPt = transformPointToCanvas(drawingPoints[0]);
                        ctx.strokeStyle = '#00ff99';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(firstPt.x, firstPt.y, 10, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    canvasRef.current.style.cursor = 'crosshair';
                    return;
                }

                if (isDraggingPoly && polyDragStartRef.current && polyDragOrigRef.current && draggedEye) {
                    let dx = m.x - polyDragStartRef.current.x;
                    let dy = m.y - polyDragStartRef.current.y;

                    // Apply 50% movement reduction when zoomed for fine-tuned positioning
                    if (isZoomed && zoomScale > 1.0) {
                        dx *= 0.5;
                        dy *= 0.5;
                    }

                    updatePolygon(draggedEye, polyDragOrigRef.current.map(p => ({ x: p.x + dx, y: p.y + dy })));
                    return;
                }

                if (draggedPointIndex !== null && draggedEye) {
                    let currentPoints;
                    if (draggedEye === 'mouth') currentPoints = polyPoints;
                    else if (draggedEye === 'leftEye') currentPoints = leftEyePoints;
                    else if (draggedEye === 'rightEye') currentPoints = rightEyePoints;

                    if (currentPoints) {
                        const newPoints = [...currentPoints];
                        newPoints[draggedPointIndex] = m;
                        updatePolygon(draggedEye, newPoints);
                    }
                    return;
                }

                // Update cursor based on what's under the mouse
                let cursor = 'default';
                const clicked = findClickedPolygon(m);
                if (clicked) {
                    if (clicked.pointIndex !== -1) cursor = 'move';
                    else cursor = isDraggingPoly ? 'grabbing' : 'grab';
                } else {
                    // Check if near edge for adding points (increased radius for touch)
                    for (const {poly} of [{poly: polyPoints}, {poly: leftEyePoints}, {poly: rightEyePoints}]) {
                        for (let i = 0; i < poly.length; i++) {
                            const p1 = poly[i];
                            const p2 = poly[(i + 1) % poly.length];
                            if (distToSegment(m, p1, p2) < 15) cursor = 'copy';
                        }
                    }
                }
                canvasRef.current.style.cursor = cursor;
            };

            const handleMouseUp = () => {
                // Clear zoom-out hold timer if it's pending
                if (zoomOutHoldTimerRef.current) {
                    clearTimeout(zoomOutHoldTimerRef.current);
                    zoomOutHoldTimerRef.current = null;
                }

                // Save to history if we were dragging
                if (draggedPointIndex !== null || draggedEye !== null || isDraggingPoly) {
                    saveToHistory();
                }

                // Clear panning state
                setIsPanning(false);
                panStartRef.current = null;
                panOffsetStartRef.current = null;

                setDraggedPointIndex(null);
                setDraggedEye(null);
                setIsDraggingPoly(false);
                polyDragStartRef.current = null;
                polyDragOrigRef.current = null;
            };

            const handleDoubleClick = (e) => {
                if(isAnimating || !image) return;
                const m = getCoords(e);

                // Check all polygons for point removal
                const clicked = findClickedPolygon(m);
                if (clicked && clicked.pointIndex !== -1) {
                    if (clicked.points.length > 3) {
                        const filtered = clicked.points.filter((_, i) => i !== clicked.pointIndex);
                        updatePolygon(clicked.type, filtered);
                        saveToHistory();
                    }
                    return;
                }

                // Check all polygons for adding points on edges (increased radius for touch)
                for (const {type, points} of [{type: 'mouth', points: polyPoints}, {type: 'leftEye', points: leftEyePoints}, {type: 'rightEye', points: rightEyePoints}]) {
                    for (let i = 0; i < points.length; i++) {
                        const p1 = points[i];
                        const p2 = points[(i + 1) % points.length];
                        if (distToSegment(m, p1, p2) < 15) {
                            const newPoints = [...points];
                            newPoints.splice(i + 1, 0, m);
                            updatePolygon(type, newPoints);
                            saveToHistory();
                            return;
                        }
                    }
                }
            };

            // Touch event handlers for mobile support
            const handleTouchStart = (e) => {
                // Don't prevent default if there's no image (allows upload zone to work)
                if (!image) return;
                e.preventDefault(); // Prevent scrolling while touching canvas
                handleMouseDown(e);
            };

            const handleTouchMove = (e) => {
                if (!image) return;
                e.preventDefault();
                handleMouseMove(e);
            };

            const handleTouchEnd = (e) => {
                if (!image) return;
                e.preventDefault();
                handleMouseUp(e);
            };

            const toggleEyePreset = (preset) => {
                if (eyePresets.includes(preset)) {
                    setEyePresets(eyePresets.filter(p => p !== preset));
                } else {
                    setEyePresets([...eyePresets, preset]);
                }
            };

            // --- 3D DENTAL ENGINE ---
            const generateMouthTexture = (w, h) => {
                if(w<1 || h<1) return;
                const cvs = document.createElement('canvas'); cvs.width = w; cvs.height = h;
                const ctx = cvs.getContext('2d');
                const cx = w / 2; const cy = h * params.current.lipSplit; 

                // 1. THROAT (Depth Gradient)
                const throat = ctx.createRadialGradient(cx, cy, 0, cx, cy, w * 0.8);
                throat.addColorStop(0, '#0a0000'); 
                throat.addColorStop(0.5, '#200505'); 
                throat.addColorStop(1, '#3a1010'); 
                ctx.fillStyle = throat; ctx.fillRect(0, 0, w, h);

                // 2. TONGUE (High Rise)
                // Use the Tongue Height slider to determine top of tongue
                // Slider 0.0 = low (floor), 1.0 = high (roof)
                const tongueTop = h - (h * 0.8 * params.current.tongueHeight); 
                const tongueW = w * 0.55;
                
                const tongue = ctx.createRadialGradient(cx, h, 0, cx, h, tongueW);
                tongue.addColorStop(0, '#c04a4a'); // Pinkish Red
                tongue.addColorStop(0.8, '#5e1919'); // Dark sides
                ctx.fillStyle = tongue; 
                ctx.beginPath();
                // Draw tongue hump
                ctx.ellipse(cx, h + (h*0.1), tongueW, (h - tongueTop) + (h*0.1), 0, 0, Math.PI * 2);
                ctx.fill();
                // Tongue Center Crease
                ctx.strokeStyle = 'rgba(80,0,0,0.1)'; ctx.lineWidth = 4;
                ctx.beginPath(); ctx.moveTo(cx, tongueTop + 10); ctx.lineTo(cx, h); ctx.stroke();

                // 3. BOTTOM MOLARS (The Depth Illusion)
                // We draw faint, dark shapes on the sides of the jaw
                const molarY = h * 0.7; // Lower jaw line
                const molarW = w * 0.2;
                ctx.fillStyle = '#2a1a1a'; // Dark tooth color
                // Left Molar
                ctx.beginPath(); ctx.ellipse(cx - w*0.35, molarY, molarW, h*0.1, 0, 0, Math.PI*2); ctx.fill();
                // Right Molar
                ctx.beginPath(); ctx.ellipse(cx + w*0.35, molarY, molarW, h*0.1, 0, 0, Math.PI*2); ctx.fill();
                // Add shading to push them back
                const shadowOverlay = ctx.createLinearGradient(0,0,0,h);
                shadowOverlay.addColorStop(0, 'rgba(0,0,0,0.5)'); 
                shadowOverlay.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = shadowOverlay; ctx.fillRect(0,0,w,h);

                // 4. TOP TEETH (3D Enamel Shader)
                const bright = Math.floor(255 * params.current.teethBrightness);
                // Calculate tint based on Shade slider (0=White, 1=Yellow)
                const shade = params.current.teethShade;
                const r = bright;
                const g = Math.floor(bright * (1 - (shade * 0.1))); // Less Green = Redder
                const b = Math.floor(bright * (1 - (shade * 0.3))); // Less Blue = Yellower
                
                const toothBase = `rgb(${r},${g},${b})`;
                const toothShadow = `rgb(${r-60},${g-60},${b-70})`;
                const toothTip = `rgba(${r+20},${g+20},${b+40},0.6)`; // Bluish translucent tip

                const teethOffset = h * params.current.teethVertical; 
                const jawGap = h * (0.3 - params.current.jawGap);
                const teethY = cy - jawGap + teethOffset; 
                
                const teethH = h * 0.18; 
                const teethW = w * 0.7 * params.current.lipWidth; // Match width to lips
                
                // Gum Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.4)'; ctx.beginPath(); 
                ctx.ellipse(cx, teethY - teethH, teethW/2, teethH/2, 0, 0, Math.PI*2); ctx.fill();

                const toothCount = 6; const startX = cx - (teethW / 2); const totalW = teethW;
                
                // Shadow Blur for "No Outlines" look
                ctx.shadowColor = "rgba(0,0,0,0.4)";
                ctx.shadowBlur = 4;

                for(let i=0; i<toothCount; i++) {
                    let relW = 1; if (i === 0 || i === 5) relW = 0.85; if (i === 1 || i === 4) relW = 0.85; if (i === 2 || i === 3) relW = 1.1; 
                    const unitW = totalW / 5.7; const tW = unitW * relW;
                    let tX = startX;
                    if(i>0) tX += (unitW * 0.85); if(i>1) tX += (unitW * 0.85); if(i>2) tX += (unitW * 1.1); if(i>3) tX += (unitW * 1.1); if(i>4) tX += (unitW * 0.85);
                    
                    const dist = Math.abs(i - 2.5); const curveY = dist * (h * 0.015);
                    const tTop = teethY - teethH - curveY; const tBot = teethY - curveY;
                    
                    // 3D Gradient
                    const grad = ctx.createLinearGradient(tX, tTop, tX, tBot);
                    grad.addColorStop(0, toothShadow); // Root
                    grad.addColorStop(0.3, toothBase); // Body
                    grad.addColorStop(0.8, toothBase); 
                    grad.addColorStop(1, toothTip); // Enamel Tip
                    ctx.fillStyle = grad; 
                    
                    ctx.beginPath(); 
                    // Round Top
                    ctx.moveTo(tX + 2, tBot); 
                    ctx.lineTo(tX + 1, tTop + 5);
                    ctx.quadraticCurveTo(tX + tW/2, tTop - 2, tX + tW - 1, tTop + 5);
                    // Square Bottom
                    ctx.lineTo(tX + tW - 2, tBot); 
                    ctx.lineTo(tX + 2, tBot); 
                    ctx.fill();
                    
                    // Specular Highlight (The "Wet" Look)
                    ctx.shadowBlur = 0; // Turn off shadow for highlight
                    ctx.fillStyle = 'rgba(255,255,255,0.3)';
                    ctx.beginPath();
                    ctx.ellipse(tX + tW*0.3, tTop + teethH*0.4, tW*0.2, teethH*0.15, 0, 0, Math.PI*2);
                    ctx.fill();
                    ctx.shadowBlur = 4; // Turn back on
                }
                ctx.shadowBlur = 0; // Reset
                mouthTextureRef.current = ctx.getImageData(0, 0, w, h).data;
            };

            const processFrame = (openAmount, ctx, bounds, mouthBuffer, maskData) => {
                if (!originalImageDataRef.current) return;

                const currentImg = ctx.getImageData(bounds.x, bounds.y, bounds.width, bounds.height);
                const dst = currentImg.data;
                const innerMouth = mouthTextureRef.current;

                const w = bounds.width; const h = bounds.height;
                const cx = w / 2;
                const activeWidthRatio = params.current.lipWidth;
                const baseSplitY = h * params.current.lipSplit;

                // Soft Edge: fade motion to zero at the top of the selection (prevents hard line near the nose)
                const softEdgePx = Math.max(10, Math.round(h * 0.18));
                const smooth01 = (t) => { t = Math.max(0, Math.min(1, t)); return t * t * (3 - 2 * t); };

                const rollPx = Math.max(0, Math.floor((params.current.lipRoll || 0) * 12));
                const rollStrength = (params.current.lipRoll || 0);

                const splitTex = (params.current.splitTexture || 0);
                const splitCol = (params.current.splitColor || 0);

                for (let x = 0; x < w; x++) {
                    const nx = (x - cx) / (w * activeWidthRatio / 2);

                    // Wave Logic
                    const mainCurve = (nx * nx) * params.current.lipCurve * (h * 0.1);
                    const bow = Math.cos(nx * Math.PI * 2.5) * params.current.cupidBow * (h * 0.05);
                    const bowFaded = bow * Math.max(0, 1 - Math.abs(nx * 1.5));
                    const localSplitY = baseSplitY - mainCurve - bowFaded;

                    const curve = (Math.abs(nx) >= 1) ? 0 : Math.cos(nx * (Math.PI / 2));
                    const shift = Math.floor(openAmount * curve);

                    if (shift > 0) {
                        let topLipY = Math.floor(localSplitY - (shift * 0.3));
                        let bottomLipY = Math.floor(localSplitY + (shift * 0.7));

                        // Jaw Gap: higher slider value = teeth closer (shrink interior opening)
                        const jawClose01 = Math.min(1, Math.max(0, (params.current.jawGap || 0) / 0.3));
                        const jawClosePx = Math.round(jawClose01 * (h * 0.06 + 6));
                        topLipY += jawClosePx;
                        bottomLipY -= jawClosePx;

                        // Consonant articulation press (strongest at center)
                        const art = params.current.articulation || 0;
                        const snap = params.current.syllableSnap || 0;
                        const centerW = Math.max(0, 1 - Math.abs(nx));
                        const pressPx = Math.round(art * centerW * (2 + 10 * snap));
                        topLipY += pressPx;
                        bottomLipY -= pressPx;

                        if (bottomLipY <= topLipY + 2) bottomLipY = topLipY + 2;

                        for (let y = 0; y < h; y++) {
                            const idx = (y * w + x) * 4;
                            if (maskData[idx + 3] === 0) continue;

                            // Mouth interior
                            if (y > topLipY && y < bottomLipY) {
                                if (innerMouth[idx + 3] > 0) {
                                    dst[idx] = innerMouth[idx];
                                    dst[idx + 1] = innerMouth[idx + 1];
                                    dst[idx + 2] = innerMouth[idx + 2];
                                    dst[idx + 3] = 255;
                                }
                                continue;
                            }

                            // Lips / surrounding (warped sampling)
                            let srcY = y; let isLipEdge = false;

                            if (y <= topLipY) {
                                srcY = y + (shift * 0.3);
                                if (srcY >= localSplitY - 3) isLipEdge = true;
                            } else if (y >= bottomLipY) {
                                const distFromChin = (y - bottomLipY);
                                const jawFalloff = Math.max(0, 1 - (distFromChin / (h * 0.6)));
                                srcY = y - (shift * 0.7 * 1.3 * jawFalloff);
                                if (srcY <= localSplitY + 3) isLipEdge = true;
                            }

                            // Pin a thin band around the split so the wet line doesn't wobble
                            const clampBand = 1 + Math.round(splitTex * 2);
                            if (isLipEdge && Math.abs(y - localSplitY) <= clampBand) srcY = y;

                            // Sub-pixel sampling (linear interp) to remove 1px jitter
                            if (srcY >= 0 && srcY < h - 1) {
                                const y0 = Math.floor(srcY);
                                const t = srcY - y0;

                                const i0 = (y0 * w + x) * 4;
                                const i1 = ((y0 + 1) * w + x) * 4;

                                const a0 = mouthBuffer[i0 + 3], a1 = mouthBuffer[i1 + 3];
                                const a = a0 * (1 - t) + a1 * t;
                                if (a <= 20) continue;

                                let r = Math.round(mouthBuffer[i0] * (1 - t) + mouthBuffer[i1] * t);
                                let g = Math.round(mouthBuffer[i0 + 1] * (1 - t) + mouthBuffer[i1 + 1] * t);
                                let b = Math.round(mouthBuffer[i0 + 2] * (1 - t) + mouthBuffer[i1 + 2] * t);

                                // --- Lip Roll: wrap texture into the inner edge near the split ---
                                if (rollPx > 0 && isLipEdge && openAmount > 2) {
                                    const edgeDist = Math.abs(srcY - localSplitY);
                                    if (edgeDist <= rollPx) {
                                        const tt = rollStrength * (1 - edgeDist / (rollPx + 1e-9));
                                        const dir = (srcY < localSplitY) ? -1 : 1;
                                        const rollSrcY = Math.round(srcY + dir * rollPx);

                                        if (rollSrcY >= 0 && rollSrcY < h) {
                                            const rollIdx = (rollSrcY * w + x) * 4;
                                            if (mouthBuffer[rollIdx + 3] > 20) {
                                                const rr = mouthBuffer[rollIdx];
                                                const gg = mouthBuffer[rollIdx + 1];
                                                const bb = mouthBuffer[rollIdx + 2];

                                                const shade = 1 - (tt * 0.12);
                                                r = Math.round((r * (1 - tt) + rr * tt) * shade);
                                                g = Math.round((g * (1 - tt) + gg * tt) * shade);
                                                b = Math.round((b * (1 - tt) + bb * tt) * shade);
                                            }
                                        }
                                    }
                                }

                                if (isLipEdge && openAmount > 2) {
                                    // Lip brighten (existing)
                                    const boost = params.current.lipLighten * 60;

                                    // Split Color tint (pinned to the split)
                                    const edge = Math.max(0, 1 - (Math.abs(y - localSplitY) / 3));
                                    const tcol = splitCol * edge;
                                    r = Math.min(255, Math.max(0, r + 40 * tcol));
                                    g = Math.min(255, Math.max(0, g - 10 * tcol));
                                    b = Math.min(255, Math.max(0, b - 18 * tcol));

                                    // Split Texture: micro-contrast + wet line (pinned to the split)
                                    if (splitTex > 0) {
                                        const dir = (y < localSplitY) ? -1 : 1;

                                        const yA = Math.max(0, Math.min(h - 1, y + dir * 1));
                                        const yB = Math.max(0, Math.min(h - 1, y - dir * 1));

                                        const aIdx = (yA * w + x) * 4;
                                        const bIdx = (yB * w + x) * 4;

                                        const la = (mouthBuffer[aIdx] * 0.299 + mouthBuffer[aIdx + 1] * 0.587 + mouthBuffer[aIdx + 2] * 0.114);
                                        const lb = (mouthBuffer[bIdx] * 0.299 + mouthBuffer[bIdx + 1] * 0.587 + mouthBuffer[bIdx + 2] * 0.114);

                                        const contrast = (la - lb) / 255;
                                        const k = splitTex * 0.35;

                                        r = Math.min(255, Math.max(0, r + contrast * 60 * k));
                                        g = Math.min(255, Math.max(0, g + contrast * 45 * k));
                                        b = Math.min(255, Math.max(0, b + contrast * 35 * k));

                                        const edgeDistY = Math.abs(y - localSplitY);
                                        const spec = Math.max(0, 1 - edgeDistY / 1.6) * splitTex * 22;

                                        r = Math.min(255, r + spec);
                                        g = Math.min(255, g + spec * 0.9);
                                        b = Math.min(255, b + spec * 0.8);
                                    }

                                    r = Math.min(255, r + boost);
                                    g = Math.min(255, g + boost);
                                    b = Math.min(255, b + boost);
                                }

                                dst[idx] = r;
                                dst[idx + 1] = g;
                                dst[idx + 2] = b;
                                dst[idx + 3] = 255;
                            }
                        }
                    }
                }

                ctx.putImageData(currentImg, bounds.x, bounds.y);
            };

            const rgbToHsl = (r, g, b) => {
                r /= 255; g /= 255; b /= 255;
                const max = Math.max(r, g, b), min = Math.min(r, g, b);
                let h, s, l = (max + min) / 2;
                if (max === min) {
                    h = s = 0;
                } else {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    switch (max) {
                        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                        case g: h = (b - r) / d + 2; break;
                        case b: h = (r - g) / d + 4; break;
                    }
                    h /= 6;
                }
                return [h, s, l];
            };

            const hslToRgb = (h, s, l) => {
                let r, g, b;
                if (s === 0) {
                    r = g = b = l;
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    };
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }
                return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
            };

            const processEyeFrame = (eyeOpen, ctx, bounds, eyeBuffer, maskData, currentPupilX, currentPupilY) => {
                if (!originalImageDataRef.current || bounds.width < 1 || bounds.height < 1) return;

                const currentImg = ctx.getImageData(bounds.x, bounds.y, bounds.width, bounds.height);
                const dst = currentImg.data;

                const w = bounds.width; const h = bounds.height;
                const cx = w / 2; const cy = h / 2;
                const baseSplitY = h * 0.5; // Eyes split horizontally

                // For eyes, we warp the upper lid down for closing or up for widening
                let maxClose = h * 0.4;
                let closeAmount = (1 - eyeOpen) * maxClose; // Negative for wide open (excited)

                for (let x = 0; x < w; x++) {
                    const nx = (x - cx) / (w / 2);
                    const curve = Math.cos(nx * (Math.PI / 2));

                    const shift = Math.floor(closeAmount * curve);

                    for (let y = 0; y < h; y++) {
                        const idx = (y * w + x) * 4;
                        if (maskData[idx + 3] === 0) continue;

                        let srcY = y;
                        let isLidEdge = false;

                        if (y < baseSplitY) {
                            // Upper lid moves down for close, up for wide
                            srcY = y - shift;
                            if (srcY < baseSplitY - Math.abs(shift) - 1) isLidEdge = true;
                        } else {
                            // Lower lid movement
                            if (closeAmount > 0) {
                                // Closing: lower lid moves up
                                srcY = y + (shift * 0.3);
                            } else if (closeAmount < 0) {
                                // Excited/wide: lower lid moves down
                                srcY = y + (shift * 0.6);
                            }
                        }

                        if (srcY < 0) srcY = 0;
                        if (srcY >= h) srcY = h - 1;

                        const y0 = Math.floor(srcY);
                        const t = srcY - y0;

                        const i0 = (y0 * w + x) * 4;
                        const i1 = Math.min((y0 + 1) * w * 4, eyeBuffer.length - 4);

                        const r = Math.round(eyeBuffer[i0] * (1 - t) + eyeBuffer[i1] * t);
                        const g = Math.round(eyeBuffer[i0 + 1] * (1 - t) + eyeBuffer[i1 + 1] * t);
                        const b = Math.round(eyeBuffer[i0 + 2] * (1 - t) + eyeBuffer[i1 + 2] * t);

                        dst[idx] = r;
                        dst[idx + 1] = g;
                        dst[idx + 2] = b;
                        dst[idx + 3] = 255;
                    }
                }

                // Draw pupil
                const pupilRadius = Math.min(w, h) * 0.15;
                const pupilCx = cx + currentPupilX * (w / 4);
                const pupilCy = cy + currentPupilY * (h / 4);

                const tempCvs = document.createElement('canvas');
                tempCvs.width = w; tempCvs.height = h;
                const tempCtx = tempCvs.getContext('2d');
                tempCtx.putImageData(currentImg, 0, 0);
                tempCtx.fillStyle = 'black';
                tempCtx.beginPath();
                tempCtx.arc(pupilCx, pupilCy, pupilRadius, 0, Math.PI * 2);
                tempCtx.fill();
                const withPupil = tempCtx.getImageData(0, 0, w, h);
                for (let i = 0; i < dst.length; i += 4) {
                    if (withPupil.data[i + 3] > 0) {
                        dst[i] = withPupil.data[i];
                        dst[i + 1] = withPupil.data[i + 1];
                        dst[i + 2] = withPupil.data[i + 2];
                    }
                }

                ctx.putImageData(currentImg, bounds.x, bounds.y);
            };

            const startAnimation = async () => {
                if (polyPoints.length < 3) {
                    setStatus("Please detect or draw mouth points first!");
                    return;
                }

                setStatus("Starting animation...");
                const bounds = getBounds(polyPoints);

                // Generate mouth texture before starting
                if (bounds.width > 0 && bounds.height > 0) {
                    generateMouthTexture(bounds.width, bounds.height);
                    console.log('Generated mouth texture:', bounds.width, 'x', bounds.height);
                } else {
                    setStatus("Invalid mouth bounds!");
                    return;
                }

                const leftEyeBounds = getBounds(leftEyePoints);
                const rightEyeBounds = getBounds(rightEyePoints);
                const ctx = canvasRef.current.getContext('2d');
                
                const maskCvs = document.createElement('canvas');
                maskCvs.width = bounds.width; maskCvs.height = bounds.height;
                const mCtx = maskCvs.getContext('2d');
                mCtx.beginPath();
                mCtx.moveTo(polyPoints[0].x - bounds.x, polyPoints[0].y - bounds.y);
                for(let i=1; i<polyPoints.length; i++) mCtx.lineTo(polyPoints[i].x - bounds.x, polyPoints[i].y - bounds.y);
                mCtx.closePath();
                mCtx.fillStyle = '#000000'; mCtx.fill();
                const maskData = mCtx.getImageData(0,0,bounds.width,bounds.height).data;

                // Eye masks
                const leftMaskCvs = document.createElement('canvas');
                leftMaskCvs.width = leftEyeBounds.width; leftMaskCvs.height = leftEyeBounds.height;
                const lCtx = leftMaskCvs.getContext('2d');
                lCtx.beginPath();
                if (leftEyePoints.length > 0) {
                    lCtx.moveTo(leftEyePoints[0].x - leftEyeBounds.x, leftEyePoints[0].y - leftEyeBounds.y);
                    for (let i = 1; i < leftEyePoints.length; i++) lCtx.lineTo(leftEyePoints[i].x - leftEyeBounds.x, leftEyePoints[i].y - leftEyeBounds.y);
                    lCtx.closePath();
                    lCtx.fill();
                }
                const leftMaskData = lCtx.getImageData(0, 0, leftEyeBounds.width, leftEyeBounds.height).data;

                const rightMaskCvs = document.createElement('canvas');
                rightMaskCvs.width = rightEyeBounds.width; rightMaskCvs.height = rightEyeBounds.height;
                const rCtx = rightMaskCvs.getContext('2d');
                rCtx.beginPath();
                if (rightEyePoints.length > 0) {
                    rCtx.moveTo(rightEyePoints[0].x - rightEyeBounds.x, rightEyePoints[0].y - rightEyeBounds.y);
                    for (let i = 1; i < rightEyePoints.length; i++) rCtx.lineTo(rightEyePoints[i].x - rightEyeBounds.x, rightEyePoints[i].y - rightEyeBounds.y);
                    rCtx.closePath();
                    rCtx.fill();
                }
                const rightMaskData = rCtx.getImageData(0, 0, rightEyeBounds.width, rightEyeBounds.height).data;

                ctx.putImageData(originalImageDataRef.current, 0, 0);
                const fullData = ctx.getImageData(0, 0, canvasRef.current.width, canvasRef.current.height);
                const mouthBuffer = new Uint8ClampedArray(bounds.width * bounds.height * 4);
                
                for(let y=0; y<bounds.height; y++) {
                    for(let x=0; x<bounds.width; x++) {
                        const s = ((bounds.y+y)*canvasRef.current.width + (bounds.x+x))*4;
                        const d = (y*bounds.width+x)*4;
                        if(s < fullData.data.length && d < mouthBuffer.length) {
                            mouthBuffer.set(fullData.data.subarray(s, s+4), d);
                        }
                    }
                }

                // Eye buffers
                const leftEyeBuffer = new Uint8ClampedArray(leftEyeBounds.width * leftEyeBounds.height * 4);
                for (let y = 0; y < leftEyeBounds.height; y++) {
                    for (let x = 0; x < leftEyeBounds.width; x++) {
                        const s = ((leftEyeBounds.y + y) * canvasRef.current.width + (leftEyeBounds.x + x)) * 4;
                        const d = (y * leftEyeBounds.width + x) * 4;
                        if (s < fullData.data.length && d < leftEyeBuffer.length) {
                            leftEyeBuffer.set(fullData.data.subarray(s, s + 4), d);
                        }
                    }
                }

                const rightEyeBuffer = new Uint8ClampedArray(rightEyeBounds.width * rightEyeBounds.height * 4);
                for (let y = 0; y < rightEyeBounds.height; y++) {
                    for (let x = 0; x < rightEyeBounds.width; x++) {
                        const s = ((rightEyeBounds.y + y) * canvasRef.current.width + (rightEyeBounds.x + x)) * 4;
                        const d = (y * rightEyeBounds.width + x) * 4;
                        if (s < fullData.data.length && d < rightEyeBuffer.length) {
                            rightEyeBuffer.set(fullData.data.subarray(s, s + 4), d);
                        }
                    }
                }

                let audioCtx = audioContextRef.current;
                if (!audioCtx || audioCtx.state === 'closed') {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    audioContextRef.current = audioCtx;
                }
                if (audioCtx.state === 'suspended') await audioCtx.resume();

                setIsAnimating(true); setRecordedVideo(null);
                const stream = canvasRef.current.captureStream(60);
                chunksRef.current = []; let analyser;

                // Determine which audio source to use
                const useAudio = exportWithAudio && audioSource !== 'none';
                const useFileAudio = (audioSource === 'file' || audioSource === 'record') && audioUrl;
                const useVideoAudio = audioSource === 'video' && backgroundType === 'video' && backgroundVideoRef.current;
                const useTTS = audioSource === 'tts';

                if (useFileAudio) {
                    const audio = new Audio(audioUrl);
                    audio.crossOrigin = "anonymous";
                    audioRef.current = audio;
                    analyser = audioCtx.createAnalyser();
                    analyser.fftSize = 2048; analyser.smoothingTimeConstant = 0.5;
                    const src = audioCtx.createMediaElementSource(audio);
                    const dest = audioCtx.createMediaStreamDestination();
                    src.connect(analyser); src.connect(audioCtx.destination); src.connect(dest);
                    if (exportWithAudio) {
                        dest.stream.getAudioTracks().forEach(t => stream.addTrack(t));
                    }
                    audio.onended = stopEverything;
                    try { await audio.play(); } catch(e) { setStatus("Autoplay blocked. Click Stop."); console.warn(e); }
                } else if (useVideoAudio) {
                    // Use background video as audio source
                    const video = backgroundVideoRef.current;
                    video.currentTime = 0;
                    video.muted = false;
                    audioRef.current = video;
                    analyser = audioCtx.createAnalyser();
                    analyser.fftSize = 2048; analyser.smoothingTimeConstant = 0.5;
                    const src = audioCtx.createMediaElementSource(video);
                    const dest = audioCtx.createMediaStreamDestination();
                    src.connect(analyser); src.connect(audioCtx.destination); src.connect(dest);
                    if (exportWithAudio) {
                        dest.stream.getAudioTracks().forEach(t => stream.addTrack(t));
                    }
                    video.onended = stopEverything;
                    try { await video.play(); } catch(e) { setStatus("Autoplay blocked. Click Stop."); console.warn(e); }
                }

                try {
                    const recorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9', videoBitsPerSecond: 8000000 });
                    recorder.ondataavailable = e => { if (e.data.size > 0) chunksRef.current.push(e.data); };
                    recorder.onstop = () => setRecordedVideo(URL.createObjectURL(new Blob(chunksRef.current, {type:'video/webm'})));
                    recorder.start();
                    mediaRecorderRef.current = recorder;
                } catch (e) { console.warn(e); }

                const dataArray = new Uint8Array(analyser ? analyser.frequencyBinCount : 0);
                const timeArray = new Uint8Array(analyser ? analyser.fftSize : 0);

                const sr = audioCtx.sampleRate;
                const hzPerBin = analyser ? (sr / analyser.fftSize) : (sr / 2048);
                const bin = (hz) => {
                    if (!dataArray.length) return 0;
                    return Math.max(0, Math.min(dataArray.length - 1, Math.round(hz / hzPerBin)));
                };

                const pLo = bin(60),   pHi = bin(200);
                const vLo = bin(180),  vHi = bin(900);
                const cLo = bin(2000), cHi = bin(4500);

                const bandAvg = (arr, lo, hi) => {
                    if (!arr.length) return 0;
                    lo = Math.max(0, Math.min(arr.length - 1, lo));
                    hi = Math.max(0, Math.min(arr.length - 1, hi));
                    if (hi < lo) { const t = lo; lo = hi; hi = t; }
                    let s = 0, c = 0;
                    for (let i = lo; i <= hi; i++) { s += arr[i]; c++; }
                    return c ? (s / c) : 0;
                };

                const startTime = Date.now();
                let currentOpenness = 0;
                let prevTarget = 0;
                let plosiveHold = 0;
                let plosivePrev = 0;
                let eyeStateTimer = 0;
                let currentEyeState = 'normal';
                let currentPupilX = 0;
                let currentPupilY = 0;
                let eyeStateDuration = 0; // How long to hold current eye state

                let frameCount = 0;
                const loop = () => {
                    frameCount++;
                    if (frameCount === 1) {
                        console.log('Animation loop started!');
                        setStatus("Animating...");
                    }

                    const elapsed = (Date.now() - startTime) / 1000;

                    let target = 0;
                    let plos = 0, cons = 0, vowel = 0;

                    if (analyser) {
                        if (frameCount === 1) console.log('Using audio analysis mode');
                        analyser.getByteTimeDomainData(timeArray);
                        let rms = 0;
                        for (let i = 0; i < timeArray.length; i++) {
                            const v = (timeArray[i] - 128) / 128;
                            rms += v * v;
                        }
                        rms = timeArray.length ? Math.sqrt(rms / timeArray.length) : 0;

                        analyser.getByteFrequencyData(dataArray);
                        plos = bandAvg(dataArray, pLo, pHi) / 255;
                        vowel = bandAvg(dataArray, vLo, vHi) / 255;
                        cons = bandAvg(dataArray, cLo, cHi) / 255;

                        target = (rms * 1.3 + vowel * 0.9 + cons * 0.8 + plos * 0.6) / (1.3 + 0.9 + 0.8 + 0.6);
                        target = Math.min(1, Math.max(0, target));
                    } else if (useTTS) {
                        if (frameCount === 1) console.log('Using TTS mode');
                        const t = elapsed;
                        target = Math.abs(Math.sin(t * 8) * 0.5 + Math.sin(t * 19) * 0.4);

                        // pseudo consonant/plosive from transients
                        plos = Math.min(1, Math.max(0, (target - prevTarget) * 3));
                        cons = Math.min(1, Math.max(0, Math.abs(Math.cos(t * 12)) * 0.35));
                    } else {
                        // No audio mode or audio not playing - use fallback animation
                        if (frameCount === 1) console.log('Using fallback animation (no audio)');
                        const t = elapsed;
                        target = Math.abs(Math.sin(t * 8) * 0.5 + Math.sin(t * 19) * 0.4);
                        plos = Math.min(1, Math.max(0, (target - prevTarget) * 3));
                        cons = Math.min(1, Math.max(0, Math.abs(Math.cos(t * 12)) * 0.35));
                    }

                    const snap = params.current.syllableSnap || 0;

                    // Plosive closure snap (P/B/M/F/V)
                    const rise = plos - plosivePrev;
                    if (plos > (0.20 - 0.05 * snap) && rise > (0.06 - 0.03 * snap)) {
                        plosiveHold = 1;
                    }
                    plosivePrev = plos;

                    plosiveHold = Math.max(0, plosiveHold - (0.18 + 0.10 * snap));
                    const closure = (0.45 + 0.35 * snap) * plosiveHold;
                    target = Math.max(0, target * (1 - closure));

                    // Sensitivity
                    target *= params.current.sensitivity;

                    // Articulation scalar for lip press
                    params.current.articulation = Math.min(1, (cons * 0.9 + plos * 1.1)) * (0.35 + 0.65 * snap);

                    // Syllable Snap shaping + attack/release
                    let tVal = Math.max(0, target);
                    tVal = Math.pow(tVal, 1 - 0.75 * snap);

                    const gate = 0.05 + 0.10 * snap;
                    tVal = Math.max(0, (tVal - gate) / (1 - gate));

                    const delta = tVal - prevTarget;
                    if (delta > 0) tVal = Math.min(1, tVal + delta * (0.9 + 1.2 * snap));

                    const base = params.current.smoothing;
                    const attack = Math.min(1, base + 0.35 * snap);
                    const release = Math.max(0.02, base * (1 - 0.55 * snap));
                    const alpha = (tVal > currentOpenness) ? attack : release;

                    currentOpenness += (tVal - currentOpenness) * alpha;
                    prevTarget = tVal;

                    const maxOpen = bounds.height * 0.45;
                    const openPixels = Math.floor(currentOpenness * maxOpen);

                    if (frameCount === 1) {
                        console.log('Processing first frame - openPixels:', openPixels, 'bounds:', bounds);
                    }

                    // Only process mouth if enabled
                    if (enableMouth) {
                        processFrame(openPixels, ctx, bounds, mouthBuffer, maskData);
                    }

                    // Eye animation - only if enabled
                    if (enableEyes) {
                        eyeStateTimer += 1 / 60;
                        let leftEyeOpen = 1;
                        let rightEyeOpen = 1;

                        // Check if it's time to change eye state
                        if (eyeStateTimer >= eyeStateDuration) {
                        eyeStateTimer = 0;
                        // Randomly pick a preset from the selected list, or stay normal
                        if (eyePresets.length > 0 && Math.random() < 0.3) {
                            const randomIndex = Math.floor(Math.random() * eyePresets.length);
                            currentEyeState = eyePresets[randomIndex];

                            // Set pupil position based on state
                            if (currentEyeState === 'look_left') { currentPupilX = -0.7; currentPupilY = 0; }
                            else if (currentEyeState === 'look_right') { currentPupilX = 0.7; currentPupilY = 0; }
                            else if (currentEyeState === 'look_up') { currentPupilX = 0; currentPupilY = -0.7; }
                            else if (currentEyeState === 'look_down') { currentPupilX = 0; currentPupilY = 0.7; }
                            else if (currentEyeState === 'eye_roll') {
                                // Eye roll will be animated in real-time below, just set initial position
                                currentPupilX = 0;
                                currentPupilY = -0.7; // Start looking up
                            }
                            else { currentPupilX = 0; currentPupilY = 0; }

                            // Duration depends on action type
                            if (currentEyeState === 'blink') eyeStateDuration = 0.15; // Quick blink
                            else if (currentEyeState === 'wink_left' || currentEyeState === 'wink_right') eyeStateDuration = 0.4; // Wink
                            else if (currentEyeState === 'excited') eyeStateDuration = 1.0 + Math.random() * 1.5; // Excited
                            else if (currentEyeState === 'glare') eyeStateDuration = 0.6 + Math.random() * 1.0; // Glare
                            else if (currentEyeState === 'eye_roll') eyeStateDuration = 1.5; // Complete roll cycle
                            else eyeStateDuration = 0.8 + Math.random() * 1.5; // Look around
                        } else {
                            currentEyeState = 'normal';
                            currentPupilX = 0;
                            currentPupilY = 0;
                            eyeStateDuration = 1.0 + Math.random() * 2.0; // Stay normal for a bit
                        }
                    }

                    // Animate eye_roll in real-time
                    if (currentEyeState === 'eye_roll') {
                        // Circular motion: progress through the roll
                        const rollProgress = eyeStateTimer / eyeStateDuration;
                        const angle = rollProgress * Math.PI * 2; // Full circle
                        currentPupilX = Math.sin(angle) * 0.7;
                        currentPupilY = -Math.cos(angle) * 0.7; // Start at top (negative Y)
                    }

                    // Set eye openness based on state (separate for left/right)
                    if (currentEyeState === 'blink') {
                        leftEyeOpen = 0;
                        rightEyeOpen = 0;
                    } else if (currentEyeState === 'wink_left') {
                        leftEyeOpen = 0;
                        rightEyeOpen = 1;
                    } else if (currentEyeState === 'wink_right') {
                        leftEyeOpen = 1;
                        rightEyeOpen = 0;
                    } else if (currentEyeState === 'glare') {
                        leftEyeOpen = 0.4;
                        rightEyeOpen = 0.4;
                    } else if (currentEyeState === 'excited') {
                        leftEyeOpen = 1.5; // Extra wide
                        rightEyeOpen = 1.5;
                    } else {
                        leftEyeOpen = 1;
                        rightEyeOpen = 1;
                    }

                        if (leftEyePoints.length > 2) processEyeFrame(leftEyeOpen, ctx, leftEyeBounds, leftEyeBuffer, leftMaskData, currentPupilX, currentPupilY);
                        if (rightEyePoints.length > 2) processEyeFrame(rightEyeOpen, ctx, rightEyeBounds, rightEyeBuffer, rightMaskData, currentPupilX, currentPupilY);
                    }

                    animationFrameRef.current = requestAnimationFrame(loop);
                };
                loop();

                if (useTTS) {
                    const u = new SpeechSynthesisUtterance(text);

                    // Intelligent voice selection based on profile parameters
                    const selectBestVoice = () => {
                        if (voices.length === 0) return null;

                        // Score each voice based on profile parameters
                        const scoredVoices = voices.map(v => {
                            let score = 0;
                            const name = v.name.toLowerCase();
                            const lang = (v.lang || '').toLowerCase();

                            // Gender matching (highest priority)
                            if (voiceGender === 'female') {
                                if (name.includes('female') || name.includes('woman') || name.includes('lady') || name.includes('girl')) score += 100;
                                else if (!name.includes('male') && !name.includes('man') && !name.includes('boy')) score += 50;
                            } else {
                                if (name.includes('male') || name.includes('man') || name.includes('boy')) score += 100;
                                else if (name.includes('david') || name.includes('james') || name.includes('daniel')) score += 80;
                            }

                            // Accent matching
                            if (voiceAccent === 'british' && (lang.includes('gb') || name.includes('british') || name.includes('daniel'))) score += 50;
                            else if (voiceAccent === 'american' && (lang.includes('us') || name.includes('american'))) score += 50;
                            else if (voiceAccent === 'australian' && (lang.includes('au') || name.includes('australian'))) score += 50;
                            else if (voiceAccent === 'neutral' && lang.includes('en')) score += 30;

                            // Timbre preference (based on voice name hints)
                            if (voiceTimbre === 'warm' && (name.includes('natural') || name.includes('daniel') || name.includes('samantha'))) score += 20;
                            else if (voiceTimbre === 'bright' && (name.includes('enhanced') || name.includes('premium'))) score += 20;
                            else if (voiceTimbre === 'neutral') score += 10;

                            // Prefer premium/enhanced voices
                            if (name.includes('premium') || name.includes('enhanced') || name.includes('natural')) score += 15;

                            return { voice: v, score };
                        });

                        // Sort by score and return best match
                        scoredVoices.sort((a, b) => b.score - a.score);
                        return scoredVoices[0].voice;
                    };

                    const selectedVoice = selectBestVoice();
                    if (selectedVoice) u.voice = selectedVoice;

                    // Apply voice controls
                    u.rate = voiceRate; // 0.1 to 2
                    u.pitch = voicePitch; // 0 to 2
                    u.volume = voiceVolume; // 0 to 1

                    u.onend = stopEverything;
                    window.speechSynthesis.speak(u);
                }
            };

            const stopEverything = () => {
                setIsAnimating(false);
                if(animationFrameRef.current) cancelAnimationFrame(animationFrameRef.current);
                if(mediaRecorderRef.current && mediaRecorderRef.current.state !== 'inactive') mediaRecorderRef.current.stop();
                if(audioRef.current) { audioRef.current.pause(); audioRef.current.currentTime = 0; }
                window.speechSynthesis.cancel();
                if(canvasRef.current && originalImageDataRef.current) {
                    const ctx = canvasRef.current.getContext('2d');
                    ctx.putImageData(originalImageDataRef.current, 0, 0);
                    drawOverlay();
                }
            };

            const handleImageUpload = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (ev) => {
                    const img = new Image();
                    img.onload = () => {
                        imageRef.current = img;
                        setImage(ev.target.result);
                        setPolyPoints([]); setLeftEyePoints([]); setRightEyePoints([]); setRecordedVideo(null);
                        setTimeout(() => {
                            const cvs = canvasRef.current;
                            const ctx = cvs.getContext('2d');
                            const MAX = 1920; 
                            const scale = Math.min(1, MAX / img.width);
                            cvs.width = Math.round(img.width * scale);
                            cvs.height = Math.round(img.height * scale);
                            ctx.imageSmoothingQuality = 'high';
                            ctx.drawImage(img, 0, 0, cvs.width, cvs.height);
                            originalImageDataRef.current = ctx.getImageData(0, 0, cvs.width, cvs.height);
                            if(modelsLoaded) autoDetect();
                        }, 50);
                    };
                    img.src = ev.target.result;
                };
                reader.readAsDataURL(file);
            };

            const autoDetect = async () => {
                setIsDetecting(true);
                try {
                    const srcCvs = canvasRef.current;
                    if (!srcCvs) return;

                    // Downscale for faster detection, then map landmarks back up
                    const maxSide = 640;
                    const scale = Math.min(1, maxSide / Math.max(srcCvs.width, srcCvs.height));
                    const detCvs = document.createElement("canvas");
                    detCvs.width = Math.round(srcCvs.width * scale);
                    detCvs.height = Math.round(srcCvs.height * scale);

                    const dctx = detCvs.getContext("2d", { willReadFrequently: true });
                    dctx.drawImage(srcCvs, 0, 0, detCvs.width, detCvs.height);

                    const opts = new faceapi.TinyFaceDetectorOptions({
                        inputSize: 224,
                        scoreThreshold: 0.4,
                    });

                    const detection = await faceapi
                        .detectSingleFace(detCvs, opts)
                        .withFaceLandmarks();

                    if (detection) {
                        const mouth = detection.landmarks.getMouth();

                        // Outer mouth ring (first 12 points), mapped back to original canvas coords
                        const outer = mouth.slice(0, 12).map((p) => ({ x: p.x / scale, y: p.y / scale }));

                        const center = outer.reduce((acc, p) => ({ x: acc.x + p.x, y: acc.y + p.y }), { x: 0, y: 0 });
                        center.x /= outer.length;
                        center.y /= outer.length;

                        const expanded = outer.map((p) => ({
                            x: center.x + (p.x - center.x) * 1.4,
                            y: center.y + (p.y - center.y) * 1.3,
                        }));

                        // Depth "chin bag" scaled to mouth size
                        const b = getBounds(expanded);
                        const chinDrop = Math.min(b.height * 0.25, 60);
                        for (let i = 6; i <= 10; i++) if (expanded[i]) expanded[i].y += chinDrop;

                        setPolyPoints(expanded);
                        setLipSplit(0.5);

                        // Eyes (combined with eyebrows for full expression control)
                        const leftEye = detection.landmarks.getLeftEye().map(p => ({x: p.x / scale, y: p.y / scale}));
                        const rightEye = detection.landmarks.getRightEye().map(p => ({x: p.x / scale, y: p.y / scale}));
                        const leftEyebrow = detection.landmarks.getLeftEyeBrow().map(p => ({x: p.x / scale, y: p.y / scale}));
                        const rightEyebrow = detection.landmarks.getRightEyeBrow().map(p => ({x: p.x / scale, y: p.y / scale}));

                        // Combine eyebrow points with eye points (eyebrows are important for expressions)
                        setLeftEyePoints([...leftEyebrow, ...leftEye]);
                        setRightEyePoints([...rightEyebrow, ...rightEye]);

                        saveToHistory();
                        drawOverlay();
                        setStatus("Detected face and eyes. Refine or animate!");
                    } else {
                        setStatus("No face detected. Use Manual Mouth Box.");
                    }
                } catch (e) {
                    console.error(e);
                    setStatus("Detect failed. Use Manual Mouth Box.");
                }
                setIsDetecting(false);
            };

            const drawOverlay = () => {
                const ctx = canvasRef.current.getContext('2d');
                const cw = canvasRef.current.width;
                const ch = canvasRef.current.height;

                // Helper function to transform points from image space to canvas space when zoomed
                const transformPointToCanvas = (p) => {
                    if (!isZoomed || zoomScale <= 1.0) return p;

                    const imageWidth = canvasRef.current.width;
                    const imageHeight = canvasRef.current.height;
                    const viewportWidth = imageWidth / zoomScale;
                    const viewportHeight = imageHeight / zoomScale;

                    const canvasX = ((p.x - panOffset.x) / viewportWidth) * imageWidth;
                    const canvasY = ((p.y - panOffset.y) / viewportHeight) * imageHeight;

                    return { x: canvasX, y: canvasY };
                };

                // Create a temporary canvas with the character image
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = cw;
                tempCanvas.height = ch;
                const tempCtx = tempCanvas.getContext('2d');

                // Use either the background-removed character or the original image
                if (bgRemovalEnabled && characterMaskRef.current) {
                    tempCtx.drawImage(characterMaskRef.current, 0, 0);
                } else if (originalImageDataRef.current) {
                    tempCtx.putImageData(originalImageDataRef.current, 0, 0);
                }

                // Clear the main canvas and draw background
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, cw, ch);

                // Draw background based on type
                if (backgroundType === 'color') {
                    ctx.fillStyle = backgroundColor;
                    ctx.fillRect(0, 0, cw, ch);
                } else if (backgroundType === 'image' && backgroundImage) {
                    // Scale and center the background image
                    const bgAspect = backgroundImage.width / backgroundImage.height;
                    const canvasAspect = cw / ch;
                    let drawW, drawH, drawX, drawY;

                    if (bgAspect > canvasAspect) {
                        drawH = ch;
                        drawW = ch * bgAspect;
                        drawX = (cw - drawW) / 2;
                        drawY = 0;
                    } else {
                        drawW = cw;
                        drawH = cw / bgAspect;
                        drawX = 0;
                        drawY = (ch - drawH) / 2;
                    }
                    ctx.drawImage(backgroundImage, drawX, drawY, drawW, drawH);
                } else if (backgroundType === 'video' && backgroundVideoRef.current) {
                    // Draw current video frame as background
                    const video = backgroundVideoRef.current;
                    const bgAspect = video.videoWidth / video.videoHeight;
                    const canvasAspect = cw / ch;
                    let drawW, drawH, drawX, drawY;

                    if (bgAspect > canvasAspect) {
                        drawH = ch;
                        drawW = ch * bgAspect;
                        drawX = (cw - drawW) / 2;
                        drawY = 0;
                    } else {
                        drawW = cw;
                        drawH = cw / bgAspect;
                        drawX = 0;
                        drawY = (ch - drawH) / 2;
                    }
                    ctx.drawImage(video, drawX, drawY, drawW, drawH);
                }

                // Draw the character on top of the background
                if (bgRemovalEnabled && characterMaskRef.current) {
                    // Position the character based on characterPosition
                    const charW = tempCanvas.width * characterPosition.scale;
                    const charH = tempCanvas.height * characterPosition.scale;
                    const charX = (cw - charW) * characterPosition.x;
                    const charY = (ch - charH) * characterPosition.y;
                    ctx.drawImage(tempCanvas, charX, charY, charW, charH);
                } else if (isZoomed && zoomScale > 1.0) {
                    // Zoomed view
                    const viewportWidth = cw / zoomScale;
                    const viewportHeight = ch / zoomScale;
                    ctx.drawImage(
                        tempCanvas,
                        panOffset.x, panOffset.y, viewportWidth, viewportHeight,
                        0, 0, cw, ch
                    );
                    ctx.fillStyle = '#00ff99';
                    ctx.font = '14px sans-serif';
                    ctx.fillText(`ZOOM: ${zoomScale.toFixed(1)}x - Drag to pan, click selection to reposition`, 20, 30);
                } else {
                    // Normal view - just draw the image
                    if (originalImageDataRef.current) {
                        ctx.putImageData(originalImageDataRef.current, 0, 0);
                    }
                }

                // Mouth
                if (enableMouth && polyPoints.length > 0) {
                    ctx.strokeStyle = '#ff00ff'; ctx.lineWidth = 2;
                    ctx.beginPath();
                    const firstPt = transformPointToCanvas(polyPoints[0]);
                    ctx.moveTo(firstPt.x, firstPt.y);
                    for (let i = 1; i < polyPoints.length; i++) {
                        const pt = transformPointToCanvas(polyPoints[i]);
                        ctx.lineTo(pt.x, pt.y);
                    }
                    ctx.closePath(); ctx.stroke();

                    ctx.fillStyle = '#fff';
                    polyPoints.forEach(p => {
                        const pt = transformPointToCanvas(p);
                        ctx.beginPath();
                        ctx.arc(pt.x, pt.y, 4, 0, Math.PI * 2);
                        ctx.fill();
                    });
                }

                // Eyes overlay for editing
                const drawEyeOverlay = (eyePoints) => {
                    if (eyePoints.length > 0) {
                        ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 2;
                        ctx.beginPath();
                        const firstPt = transformPointToCanvas(eyePoints[0]);
                        ctx.moveTo(firstPt.x, firstPt.y);
                        for (let i = 1; i < eyePoints.length; i++) {
                            const pt = transformPointToCanvas(eyePoints[i]);
                            ctx.lineTo(pt.x, pt.y);
                        }
                        ctx.closePath(); ctx.stroke();

                        ctx.fillStyle = '#fff';
                        eyePoints.forEach(p => {
                            const pt = transformPointToCanvas(p);
                            ctx.beginPath();
                            ctx.arc(pt.x, pt.y, 3, 0, Math.PI * 2);
                            ctx.fill();
                        });
                    }
                };
                if (enableEyes) {
                    drawEyeOverlay(leftEyePoints);
                    drawEyeOverlay(rightEyePoints);
                }

                // Guides for mouth
                if (polyPoints.length > 0) {
                    const b = getBounds(polyPoints);
                    const lipW = b.width * params.current.lipWidth;
                    const lx = b.x + (b.width - lipW) / 2;
                    const cx = b.x + b.width / 2;
                    const baseSplitY = b.y + (b.height * params.current.lipSplit);

                    // Curved split guide (shows Cupid's Bow + Smile Curve impact)
                    ctx.strokeStyle = '#00ff99';
                    ctx.setLineDash([5, 5]);
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    const N = 80;
                    for (let i = 0; i <= N; i++) {
                        const x = b.x + (i / N) * b.width;
                        const nx = (x - cx) / (lipW / 2);
                        const mainCurve = (nx * nx) * params.current.lipCurve * (b.height * 0.1);
                        const bow = Math.cos(nx * Math.PI * 2.5) * params.current.cupidBow * (b.height * 0.05);
                        const bowFaded = bow * Math.max(0, 1 - Math.abs(nx * 1.5));
                        const y = baseSplitY - mainCurve - bowFaded;
                        // Transform point to canvas space when zoomed
                        const transformed = transformPointToCanvas({ x, y });
                        if (i === 0) ctx.moveTo(transformed.x, transformed.y); else ctx.lineTo(transformed.x, transformed.y);
                    }
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Lip width box
                    ctx.strokeStyle = '#ffae00';
                    ctx.lineWidth = 1;
                    // Transform the rectangle corners when zoomed
                    const topLeft = transformPointToCanvas({ x: lx, y: baseSplitY - 10 });
                    const bottomRight = transformPointToCanvas({ x: lx + lipW, y: baseSplitY + 10 });
                    ctx.strokeRect(topLeft.x, topLeft.y, bottomRight.x - topLeft.x, bottomRight.y - topLeft.y);
                }
            };

            const resetAll = () => { stopEverything(); setImage(null); setRecordedVideo(null); setPolyPoints([]); setLeftEyePoints([]); setRightEyePoints([]); };

            return (
                <div className="layout">
                    <div
                        className="stage"
                        onMouseDown={handleMouseDown}
                        onMouseMove={handleMouseMove}
                        onMouseUp={handleMouseUp}
                        onDoubleClick={handleDoubleClick}
                        onTouchStart={handleTouchStart}
                        onTouchMove={handleTouchMove}
                        onTouchEnd={handleTouchEnd}
                    >
                        {!image && <div className="upload-zone" onClick={()=>document.getElementById('imgIn').click()}><h2>Upload Photo</h2><p>High Resolution Recommended</p><input id="imgIn" type="file" onChange={handleImageUpload} style={{display:'none'}} accept="image/*" /></div>}
                        <canvas ref={canvasRef} style={{opacity: image?1:0, touchAction: 'none'}} />
                        {isDetecting && <div className="overlay-msg"><div className="spinner"></div><span>Scanning Face...</span></div>}
                    </div>

                    <div className="controls">
                        <h1>Lip Sync Pro</h1>
                        <div className="panel">
                            <h3>Setup</h3>
                            <div className="btn-row">
                                <button className="btn" onClick={autoDetect} disabled={!image || isAnimating}>Auto-Detect</button>
                                <button className="btn btn-danger" onClick={resetAll}>Reset</button>
                            </div>

                            <h3 style={{marginTop: 15, fontSize: '0.9rem'}}>Manual Draw</h3>
                            <div className="btn-row" style={{alignItems: 'center'}}>
                                <select
                                    value={manualDrawFeature}
                                    onChange={e => setManualDrawFeature(e.target.value)}
                                    disabled={!image || isAnimating || manualDrawMode}
                                    style={{
                                        flex: 1,
                                        padding: '10px',
                                        borderRadius: '6px',
                                        border: '1px solid #444',
                                        background: '#2a2a2a',
                                        color: '#fff',
                                        fontSize: '0.85rem',
                                        cursor: 'pointer'
                                    }}
                                >
                                    <option value="mouth">Mouth</option>
                                    <option value="leftEye">Left Eye</option>
                                    <option value="rightEye">Right Eye</option>
                                    <option value="leftBrow">Left Eyebrow</option>
                                    <option value="rightBrow">Right Eyebrow</option>
                                </select>
                                <button
                                    className={`btn ${manualDrawMode ? 'btn-primary' : ''}`}
                                    onClick={() => {
                                        if (manualDrawMode) {
                                            setManualDrawMode(false);
                                            setDrawingPoints([]);
                                            drawOverlay();
                                        } else {
                                            setManualDrawMode(true);
                                            setDrawingPoints([]);
                                        }
                                    }}
                                    disabled={!image || isAnimating}
                                    title="Click to place anchor points, click on first point to close the shape"
                                    style={{minWidth: '100px'}}
                                >
                                    {manualDrawMode ? 'Cancel' : 'Draw'}
                                </button>
                            </div>
                            {manualDrawMode && (
                                <p style={{fontSize: '0.75rem', color: '#00ff99', marginTop: 8}}>
                                    Click to place points. Click on the green dot to close the shape.
                                    {drawingPoints.length > 0 && ` (${drawingPoints.length} points placed)`}
                                </p>
                            )}

                            <h3 style={{marginTop: 15, fontSize: '0.9rem'}}>Zoom & Pan</h3>
                            <div className="btn-row">
                                <button
                                    className={`btn ${isZoomed ? 'btn-primary' : ''}`}
                                    onClick={() => {
                                        if (isZoomed) {
                                            setIsZoomed(false);
                                            setZoomScale(1.0);
                                            setPanOffset({ x: 0, y: 0 });
                                        } else {
                                            setIsZoomed(true);
                                            const newZoomScale = 2.5;
                                            setZoomScale(newZoomScale);

                                            // Auto-center on mouth when zooming in
                                            if (polyPoints.length > 0 && canvasRef.current) {
                                                const bounds = getBounds(polyPoints);
                                                const imageWidth = canvasRef.current.width;
                                                const imageHeight = canvasRef.current.height;
                                                const viewportWidth = imageWidth / newZoomScale;
                                                const viewportHeight = imageHeight / newZoomScale;

                                                // Center the viewport on the mouth center
                                                const mouthCenterX = bounds.x + bounds.width / 2;
                                                const mouthCenterY = bounds.y + bounds.height / 2;

                                                let newPanX = mouthCenterX - viewportWidth / 2;
                                                let newPanY = mouthCenterY - viewportHeight / 2;

                                                // Clamp to image bounds
                                                newPanX = Math.max(0, Math.min(imageWidth - viewportWidth, newPanX));
                                                newPanY = Math.max(0, Math.min(imageHeight - viewportHeight, newPanY));

                                                setPanOffset({ x: newPanX, y: newPanY });
                                            }
                                        }
                                        setTimeout(drawOverlay, 10);
                                    }}
                                    disabled={!image || isAnimating}
                                >
                                    {isZoomed ? 'Zoom Out' : 'Zoom In'}
                                </button>
                            </div>
                            {isZoomed && (
                                <>
                                    <div className="slider-row" style={{marginTop: 10}}>
                                        <label>Zoom Level</label>
                                        <input
                                            type="range"
                                            min="1.5"
                                            max="5"
                                            step="0.5"
                                            value={zoomScale}
                                            onChange={e => { setZoomScale(Number(e.target.value)); setTimeout(drawOverlay, 10); }}
                                        />
                                        <span style={{fontSize: '0.7rem', color: '#888'}}>{zoomScale.toFixed(1)}x</span>
                                    </div>
                                    <p style={{fontSize: '0.7rem', color: '#888', marginTop: 5}}>
                                        Drag to pan. Click selection to reposition (auto-zooms out).
                                    </p>
                                </>
                            )}

                            <div className="hint">
                                Tip: Drag points to refine. Drag inside the shape to move it. Use Manual Draw to create shapes by clicking.
                            </div>
                        </div>

                        <div className="panel">
                            <h3>Background Removal</h3>
                            <div className="btn-row">
                                <button
                                    className="btn"
                                    onClick={removeBackground}
                                    disabled={!image || isAnimating || isRemovingBg}
                                >
                                    {isRemovingBg ? 'Processing...' : 'Remove Background'}
                                </button>
                                <button
                                    className="btn btn-danger"
                                    onClick={resetBackgroundRemoval}
                                    disabled={!bgRemovalEnabled}
                                >
                                    Reset
                                </button>
                            </div>
                            {bgRemovalEnabled && (
                                <>
                                    <div className="slider-row" style={{marginTop: 10}}>
                                        <label>Threshold</label>
                                        <input
                                            type="range"
                                            min="0.1"
                                            max="0.9"
                                            step="0.05"
                                            value={bgRemovalThreshold}
                                            onChange={e => { setBgRemovalThreshold(Number(e.target.value)); removeBackground(); }}
                                        />
                                        <span style={{fontSize: '0.7rem', color: '#888'}}>{bgRemovalThreshold.toFixed(2)}</span>
                                    </div>
                                    <div className="slider-row">
                                        <label>Edge Softness</label>
                                        <input
                                            type="range"
                                            min="0.01"
                                            max="0.3"
                                            step="0.01"
                                            value={bgRemovalEdge}
                                            onChange={e => { setBgRemovalEdge(Number(e.target.value)); removeBackground(); }}
                                        />
                                        <span style={{fontSize: '0.7rem', color: '#888'}}>{bgRemovalEdge.toFixed(2)}</span>
                                    </div>
                                </>
                            )}
                        </div>

                        <div className="panel">
                            <h3>Background</h3>
                            <div className="tabs" style={{marginBottom: 10}}>
                                <div className={`tab ${backgroundType === 'none' ? 'active' : ''}`} onClick={() => { setBackgroundType('none'); drawOverlay(); }}>None</div>
                                <div className={`tab ${backgroundType === 'color' ? 'active' : ''}`} onClick={() => { setBackgroundType('color'); drawOverlay(); }}>Color</div>
                                <div className={`tab ${backgroundType === 'image' ? 'active' : ''}`} onClick={() => setBackgroundType('image')}>Image</div>
                                <div className={`tab ${backgroundType === 'video' ? 'active' : ''}`} onClick={() => setBackgroundType('video')}>Video</div>
                            </div>

                            {backgroundType === 'color' && (
                                <div className="btn-row" style={{alignItems: 'center'}}>
                                    <label style={{fontSize: '0.8rem', color: '#aaa'}}>Color:</label>
                                    <input
                                        type="color"
                                        value={backgroundColor}
                                        onChange={e => { setBackgroundColor(e.target.value); drawOverlay(); }}
                                        style={{flex: 1, height: 35, cursor: 'pointer'}}
                                    />
                                </div>
                            )}

                            {backgroundType === 'image' && (
                                <div className="btn-row">
                                    <button className="btn" onClick={() => document.getElementById('bgImgIn').click()}>
                                        {backgroundImage ? 'Change Image' : 'Load Image'}
                                    </button>
                                    <input id="bgImgIn" type="file" onChange={handleBackgroundImageUpload} style={{display:'none'}} accept="image/*" />
                                    {backgroundImage && (
                                        <button className="btn btn-danger" onClick={clearBackground}>Clear</button>
                                    )}
                                </div>
                            )}

                            {backgroundType === 'video' && (
                                <div className="btn-row">
                                    <button className="btn" onClick={() => document.getElementById('bgVidIn').click()}>
                                        {backgroundVideo ? 'Change Video' : 'Load Video'}
                                    </button>
                                    <input id="bgVidIn" type="file" onChange={handleBackgroundVideoUpload} style={{display:'none'}} accept="video/*" />
                                    {backgroundVideo && (
                                        <button className="btn btn-danger" onClick={clearBackground}>Clear</button>
                                    )}
                                </div>
                            )}

                            {bgRemovalEnabled && backgroundType !== 'none' && (
                                <>
                                    <h3 style={{marginTop: 15, fontSize: '0.9rem'}}>Character Position</h3>
                                    <div className="slider-row">
                                        <label>Horizontal</label>
                                        <input
                                            type="range"
                                            min="0"
                                            max="1"
                                            step="0.01"
                                            value={characterPosition.x}
                                            onChange={e => { setCharacterPosition(prev => ({...prev, x: Number(e.target.value)})); drawOverlay(); }}
                                        />
                                        <span style={{fontSize: '0.7rem', color: '#888'}}>{(characterPosition.x * 100).toFixed(0)}%</span>
                                    </div>
                                    <div className="slider-row">
                                        <label>Vertical</label>
                                        <input
                                            type="range"
                                            min="0"
                                            max="1"
                                            step="0.01"
                                            value={characterPosition.y}
                                            onChange={e => { setCharacterPosition(prev => ({...prev, y: Number(e.target.value)})); drawOverlay(); }}
                                        />
                                        <span style={{fontSize: '0.7rem', color: '#888'}}>{(characterPosition.y * 100).toFixed(0)}%</span>
                                    </div>
                                    <div className="slider-row">
                                        <label>Scale</label>
                                        <input
                                            type="range"
                                            min="0.2"
                                            max="2"
                                            step="0.05"
                                            value={characterPosition.scale}
                                            onChange={e => { setCharacterPosition(prev => ({...prev, scale: Number(e.target.value)})); drawOverlay(); }}
                                        />
                                        <span style={{fontSize: '0.7rem', color: '#888'}}>{(characterPosition.scale * 100).toFixed(0)}%</span>
                                    </div>
                                </>
                            )}
                        </div>

                        <div className="panel">
                            <h3>Undo/Redo</h3>
                            <div className="btn-row">
                                <button className="btn" onClick={undo} disabled={historyIndex <= 0}>
                                    Undo
                                </button>
                                <button className="btn" onClick={redo} disabled={historyIndex >= history.length - 1}>
                                    Redo
                                </button>
                            </div>
                            <p style={{fontSize: '0.7rem', color: '#888', marginTop: 5}}>
                                {history.length > 0 ? `${historyIndex + 1} / ${history.length}` : 'No history'}
                            </p>
                        </div>

                        <div className="panel">
                            <h3>Feature Toggles</h3>
                            <p style={{fontSize: '0.75rem', color: '#888', marginBottom: '10px'}}>
                                Enable or disable animation features
                            </p>
                            <div style={{display: 'flex', flexDirection: 'column', gap: '8px'}}>
                                <label style={{display: 'flex', alignItems: 'center', cursor: 'pointer'}}>
                                    <input
                                        type="checkbox"
                                        checked={enableMouth}
                                        onChange={e => setEnableMouth(e.target.checked)}
                                        style={{marginRight: '8px'}}
                                    />
                                    Enable Mouth Animation
                                </label>
                                <label style={{display: 'flex', alignItems: 'center', cursor: 'pointer'}}>
                                    <input
                                        type="checkbox"
                                        checked={enableEyes}
                                        onChange={e => setEnableEyes(e.target.checked)}
                                        style={{marginRight: '8px'}}
                                    />
                                    Enable Eye Animation (includes eyebrows)
                                </label>
                            </div>
                        </div>

                        <div className="panel">
                            <h3>Audio Source</h3>
                            <div className="tabs">
                                <div className={`tab ${audioSource==='none'?'active':''}`} onClick={()=>setAudioSource('none')}>None</div>
                                <div className={`tab ${audioSource==='file'?'active':''}`} onClick={()=>setAudioSource('file')}>File</div>
                                <div className={`tab ${audioSource==='record'?'active':''}`} onClick={()=>setAudioSource('record')}>Record</div>
                                <div className={`tab ${audioSource==='video'?'active':''}`} onClick={()=>setAudioSource('video')}>Video</div>
                                <div className={`tab ${audioSource==='tts'?'active':''}`} onClick={()=>setAudioSource('tts')}>TTS</div>
                            </div>

                            {audioSource === 'none' && (
                                <div style={{padding: '15px 0', color: '#888', textAlign: 'center', fontSize: '0.85rem'}}>
                                    Animation will play without audio.<br/>
                                    Mouth will use fallback sine wave motion.
                                </div>
                            )}

                            {audioSource === 'file' && (
                                <div>
                                    <input type="file" accept="audio/*" onChange={(e)=>{if(e.target.files[0]){setAudioUrl(URL.createObjectURL(e.target.files[0])); setActiveTab('audio');}}} style={{marginTop: 10}} />
                                    {audioUrl && <audio src={audioUrl} controls style={{width:'100%', marginTop:10}} />}
                                </div>
                            )}

                            {audioSource === 'record' && (
                                <div>
                                    <div className="btn-row" style={{marginTop: 10}}>
                                        <button className="btn" onClick={startVoiceRecord} disabled={isRecordingVoice}>Record Voice</button>
                                        <button className="btn btn-danger" onClick={stopVoiceRecord} disabled={!isRecordingVoice}>Stop Recording</button>
                                    </div>
                                    {audioUrl && <audio src={audioUrl} controls style={{width:'100%', marginTop:10}} />}
                                </div>
                            )}

                            {audioSource === 'video' && (
                                <div style={{padding: '10px 0'}}>
                                    {backgroundType === 'video' && backgroundVideo ? (
                                        <div style={{color: '#00ff99', fontSize: '0.85rem'}}>
                                            Audio will be synced from the loaded background video.
                                        </div>
                                    ) : (
                                        <div style={{color: '#ff6666', fontSize: '0.85rem'}}>
                                            Load a background video first to use its audio.
                                        </div>
                                    )}
                                </div>
                            )}

                            {audioSource === 'tts' && (
                                <div>
                                    <textarea value={text} onChange={e=>setText(e.target.value)} style={{width:'100%', background:'#1a1a1a', color:'#fff', border:'none', padding:10, borderRadius:4, minHeight:60}} />

                                    <h3 style={{marginTop: 15, fontSize: '0.8rem'}}>Voice Customization</h3>

                                    <div style={{marginTop: 10}}>
                                        <label style={{fontSize: '0.8rem', color: '#aaa', marginBottom: 5, display: 'block'}}>Gender</label>
                                        <div className="btn-row">
                                            <button
                                                className={`btn ${voiceGender === 'female' ? 'btn-primary' : ''}`}
                                                onClick={() => setVoiceGender('female')}
                                                style={{flex: 1}}
                                            >
                                                Female
                                            </button>
                                            <button
                                                className={`btn ${voiceGender === 'male' ? 'btn-primary' : ''}`}
                                                onClick={() => setVoiceGender('male')}
                                                style={{flex: 1}}
                                            >
                                                Male
                                            </button>
                                        </div>
                                    </div>

                                    <div className="slider-row" style={{marginTop: 10}}>
                                        <label>Speed</label>
                                        <input type="range" min="0.1" max="2" step="0.1" value={voiceRate} onChange={e=>setVoiceRate(Number(e.target.value))} />
                                        <span style={{fontSize: '0.7rem', color: '#888'}}>{voiceRate.toFixed(1)}x</span>
                                    </div>

                                    <div className="slider-row">
                                        <label>Pitch</label>
                                        <input type="range" min="0" max="2" step="0.1" value={voicePitch} onChange={e=>setVoicePitch(Number(e.target.value))} />
                                        <span style={{fontSize: '0.7rem', color: '#888'}}>{voicePitch.toFixed(1)}</span>
                                    </div>

                                    <div className="slider-row">
                                        <label>Volume</label>
                                        <input type="range" min="0" max="1" step="0.1" value={voiceVolume} onChange={e=>setVoiceVolume(Number(e.target.value))} />
                                        <span style={{fontSize: '0.7rem', color: '#888'}}>{(voiceVolume * 100).toFixed(0)}%</span>
                                    </div>

                                    <div style={{marginTop: 15}}>
                                        <label style={{fontSize: '0.8rem', color: '#aaa', marginBottom: 5, display: 'block'}}>Timbre</label>
                                        <div className="btn-row">
                                            <button
                                                className={`btn ${voiceTimbre === 'warm' ? 'btn-primary' : ''}`}
                                                onClick={() => setVoiceTimbre('warm')}
                                                style={{flex: 1, fontSize: '0.75rem'}}
                                            >
                                                Warm
                                            </button>
                                            <button
                                                className={`btn ${voiceTimbre === 'neutral' ? 'btn-primary' : ''}`}
                                                onClick={() => setVoiceTimbre('neutral')}
                                                style={{flex: 1, fontSize: '0.75rem'}}
                                            >
                                                Neutral
                                            </button>
                                            <button
                                                className={`btn ${voiceTimbre === 'bright' ? 'btn-primary' : ''}`}
                                                onClick={() => setVoiceTimbre('bright')}
                                                style={{flex: 1, fontSize: '0.75rem'}}
                                            >
                                                Bright
                                            </button>
                                        </div>
                                    </div>

                                    <div style={{marginTop: 15}}>
                                        <label style={{fontSize: '0.8rem', color: '#aaa', marginBottom: 5, display: 'block'}}>Accent</label>
                                        <div className="btn-row" style={{marginBottom: 5}}>
                                            <button
                                                className={`btn ${voiceAccent === 'neutral' ? 'btn-primary' : ''}`}
                                                onClick={() => setVoiceAccent('neutral')}
                                                style={{flex: 1, fontSize: '0.75rem'}}
                                            >
                                                Neutral
                                            </button>
                                            <button
                                                className={`btn ${voiceAccent === 'american' ? 'btn-primary' : ''}`}
                                                onClick={() => setVoiceAccent('american')}
                                                style={{flex: 1, fontSize: '0.75rem'}}
                                            >
                                                American
                                            </button>
                                        </div>
                                        <div className="btn-row">
                                            <button
                                                className={`btn ${voiceAccent === 'british' ? 'btn-primary' : ''}`}
                                                onClick={() => setVoiceAccent('british')}
                                                style={{flex: 1, fontSize: '0.75rem'}}
                                            >
                                                British
                                            </button>
                                            <button
                                                className={`btn ${voiceAccent === 'australian' ? 'btn-primary' : ''}`}
                                                onClick={() => setVoiceAccent('australian')}
                                                style={{flex: 1, fontSize: '0.75rem'}}
                                            >
                                                Australian
                                            </button>
                                        </div>
                                    </div>

                                    <h3 style={{marginTop: 20, fontSize: '0.8rem', borderTop: '1px solid #333', paddingTop: 15}}>Voice Profiles</h3>

                                    <div style={{marginTop: 10}}>
                                        <div className="btn-row" style={{marginBottom: 10}}>
                                            <input
                                                id="profileNameInput"
                                                type="text"
                                                placeholder="Profile name..."
                                                style={{flex: 1, background:'#1a1a1a', color:'#fff', border:'1px solid #333', padding:6, borderRadius:4, fontSize:'0.8rem'}}
                                            />
                                            <button
                                                className="btn btn-primary"
                                                onClick={() => {
                                                    const input = document.getElementById('profileNameInput');
                                                    if (input && input.value) {
                                                        saveVoiceProfile(input.value);
                                                        input.value = '';
                                                    }
                                                }}
                                                style={{fontSize: '0.75rem'}}
                                            >
                                                Save
                                            </button>
                                        </div>

                                        <div style={{marginBottom: 10}}>
                                            <label htmlFor="importProfileInput" className="btn" style={{fontSize: '0.75rem', cursor: 'pointer', display: 'inline-block', textAlign: 'center'}}>
                                                Import Profile
                                            </label>
                                            <input
                                                id="importProfileInput"
                                                type="file"
                                                accept=".json"
                                                onChange={importVoiceProfile}
                                                style={{display: 'none'}}
                                            />
                                        </div>

                                        {savedVoiceProfiles.length > 0 && (
                                            <div style={{maxHeight: '200px', overflowY: 'auto', border: '1px solid #333', borderRadius: 4, padding: 8}}>
                                                {savedVoiceProfiles.map(profile => (
                                                    <div key={profile.name} style={{
                                                        background: '#1a1a1a',
                                                        padding: 8,
                                                        marginBottom: 6,
                                                        borderRadius: 4,
                                                        display: 'flex',
                                                        alignItems: 'center',
                                                        gap: 6
                                                    }}>
                                                        <div style={{flex: 1, fontSize: '0.8rem'}}>
                                                            <div style={{fontWeight: 'bold', marginBottom: 2}}>{profile.name}</div>
                                                            <div style={{fontSize: '0.7rem', color: '#888'}}>
                                                                {profile.gender}  {profile.accent}  {profile.timbre}
                                                            </div>
                                                        </div>
                                                        <button
                                                            className="btn btn-primary"
                                                            onClick={() => loadVoiceProfile(profile)}
                                                            style={{fontSize: '0.7rem', padding: '4px 8px'}}
                                                        >
                                                            Load
                                                        </button>
                                                        <button
                                                            className="btn"
                                                            onClick={() => exportVoiceProfile(profile)}
                                                            style={{fontSize: '0.7rem', padding: '4px 8px'}}
                                                        >
                                                            Export
                                                        </button>
                                                        <button
                                                            className="btn btn-danger"
                                                            onClick={() => deleteVoiceProfile(profile.name)}
                                                            style={{fontSize: '0.7rem', padding: '4px 8px'}}
                                                        >
                                                            
                                                        </button>
                                                    </div>
                                                ))}
                                            </div>
                                        )}
                                    </div>
                                </div>
                            )}
                        </div>

                        <div className="panel">
                            <h3>Lip Geometry</h3>
                            <div className="slider-row">
                                <label style={{color:'#ffae00'}}>Lip Width</label>
                                <input type="range" min="0.3" max="1.0" step="0.05" value={lipWidth} onChange={e=>setLipWidth(Number(e.target.value))} />
                            </div>
                            <div className="slider-row">
                                <label style={{color:'#00ff99'}}>Vertical Center</label>
                                <input type="range" min="0.3" max="0.7" step="0.01" value={lipSplit} onChange={e=>setLipSplit(Number(e.target.value))} />
                            </div>
                            <div className="slider-row">
                                <label>Cupid's Bow</label>
                                <input type="range" min="-1.0" max="1.0" step="0.05" value={cupidBow} onChange={e=>setCupidBow(Number(e.target.value))} />
                            </div>
                            <div className="slider-row">
                                <label>Smile Curve</label>
                                <input type="range" min="-0.5" max="0.5" step="0.05" value={lipCurve} onChange={e=>setLipCurve(Number(e.target.value))} />
                            </div>
                        </div>

                        <div className="panel">
                            <h3>3D Anatomy</h3>

                            <div className="slider-row">
                                <label>Jaw Gap</label>
                                <input type="range" min="0" max="0.3" step="0.01" value={jawGap} onChange={e=>setJawGap(Number(e.target.value))} />
                            </div>

                            <div className="slider-row">
                                <label>Teeth Brightness</label>
                                <input type="range" min="0.2" max="1" step="0.05" value={teethBrightness} onChange={e=>setTeethBrightness(Number(e.target.value))} />
                            </div>

                            <div className="slider-row">
                                <label>Teeth Vertical</label>
                                <input type="range" min="-0.2" max="0.2" step="0.01" value={teethVertical} onChange={e=>setTeethVertical(Number(e.target.value))} />
                            </div>

                            <div className="slider-row">
                                <label>Teeth Shade</label>
                                <input type="range" min="0" max="1" step="0.1" value={teethShade} onChange={e=>setTeethShade(Number(e.target.value))} />
                            </div>

                            <div className="slider-row">
                                <label>Tongue Height</label>
                                <input type="range" min="0" max="1.5" step="0.1" value={tongueHeight} onChange={e=>setTongueHeight(Number(e.target.value))} />
                            </div>

                            <div className="slider-row">
                                <label>Lip Lighten</label>
                                <input type="range" min="0" max="1" step="0.1" value={lipLighten} onChange={e=>setLipLighten(Number(e.target.value))} />
                            </div>

                            <div className="slider-row">
                                <label>Split Color</label>
                                <input type="range" min="0" max="1" step="0.05" value={splitColor} onChange={e=>setSplitColor(Number(e.target.value))} />
                            </div>

                            <div className="slider-row">
                                <label>Split Texture</label>
                                <input type="range" min="0" max="1" step="0.05" value={splitTexture} onChange={e=>setSplitTexture(Number(e.target.value))} />
                            </div>
                        </div>

                        <div className="panel">
                            <h3>Animation Tuning</h3>
                            <div className="slider-row">
                                <label>Sensitivity</label>
                                <input type="range" min="0.2" max="3" step="0.1" value={sensitivity} onChange={e=>setSensitivity(Number(e.target.value))} />
                            </div>

                            <div className="slider-row">
                                <label>Lip Roll</label>
                                <input type="range" min="0" max="1" step="0.05" value={lipRoll} onChange={e=>setLipRoll(Number(e.target.value))} />
                            </div>

                            <div className="slider-row">
                                <label>Syllable Snap</label>
                                <input type="range" min="0" max="1" step="0.05" value={syllableSnap} onChange={e=>setSyllableSnap(Number(e.target.value))} />
                            </div>

                            <div className="slider-row">
                                <label>Smoothing</label>
                                <input type="range" min="0.02" max="0.6" step="0.01" value={smoothing} onChange={e=>setSmoothing(Number(e.target.value))} />
                            </div>
                        </div>

                        <div className="panel">
                            <h3>Eye Animation Presets</h3>
                            <p style={{fontSize: '0.75rem', color: '#888', marginBottom: '10px'}}>
                                Select actions to randomly apply during animation. Eye selections include eyebrows for full expression control!
                            </p>
                            <div className="btn-row">
                                <button
                                    className={`btn ${eyePresets.includes('blink') ? 'btn-primary' : ''}`}
                                    onClick={() => toggleEyePreset('blink')}
                                >
                                    Blink
                                </button>
                                <button
                                    className={`btn ${eyePresets.includes('wink_left') ? 'btn-primary' : ''}`}
                                    onClick={() => toggleEyePreset('wink_left')}
                                >
                                    Wink Left
                                </button>
                                <button
                                    className={`btn ${eyePresets.includes('wink_right') ? 'btn-primary' : ''}`}
                                    onClick={() => toggleEyePreset('wink_right')}
                                >
                                    Wink Right
                                </button>
                            </div>
                            <div className="btn-row">
                                <button
                                    className={`btn ${eyePresets.includes('excited') ? 'btn-primary' : ''}`}
                                    onClick={() => toggleEyePreset('excited')}
                                >
                                    Excited
                                </button>
                                <button
                                    className={`btn ${eyePresets.includes('glare') ? 'btn-primary' : ''}`}
                                    onClick={() => toggleEyePreset('glare')}
                                >
                                    Glare
                                </button>
                            </div>
                            <div className="btn-row">
                                <button
                                    className={`btn ${eyePresets.includes('look_left') ? 'btn-primary' : ''}`}
                                    onClick={() => toggleEyePreset('look_left')}
                                >
                                    Look Left
                                </button>
                                <button
                                    className={`btn ${eyePresets.includes('look_right') ? 'btn-primary' : ''}`}
                                    onClick={() => toggleEyePreset('look_right')}
                                >
                                    Look Right
                                </button>
                            </div>
                            <div className="btn-row">
                                <button
                                    className={`btn ${eyePresets.includes('look_up') ? 'btn-primary' : ''}`}
                                    onClick={() => toggleEyePreset('look_up')}
                                >
                                    Look Up
                                </button>
                                <button
                                    className={`btn ${eyePresets.includes('look_down') ? 'btn-primary' : ''}`}
                                    onClick={() => toggleEyePreset('look_down')}
                                >
                                    Look Down
                                </button>
                            </div>
                            <div className="btn-row">
                                <button
                                    className={`btn ${eyePresets.includes('eye_roll') ? 'btn-primary' : ''}`}
                                    onClick={() => toggleEyePreset('eye_roll')}
                                >
                                    Eye Roll
                                </button>
                            </div>
                        </div>

                        <div className="panel">
                            <h3>Drafts</h3>
                            <div className="btn-row">
                                <button className="btn" onClick={saveDraft}>Save Draft</button>
                                <button className="btn btn-danger" onClick={clearDraft}>Clear Draft</button>
                            </div>
                        </div>

                        <div className="panel">
                            <h3>Export Options</h3>
                            <label style={{display: 'flex', alignItems: 'center', gap: 8, cursor: 'pointer', marginBottom: 8}}>
                                <input
                                    type="checkbox"
                                    checked={exportWithAudio}
                                    onChange={e => setExportWithAudio(e.target.checked)}
                                    style={{accentColor: 'var(--accent)'}}
                                />
                                <span style={{fontSize: '0.85rem'}}>Include Audio</span>
                            </label>
                            <label style={{display: 'flex', alignItems: 'center', gap: 8, cursor: 'pointer'}}>
                                <input
                                    type="checkbox"
                                    checked={exportWithBackground}
                                    onChange={e => setExportWithBackground(e.target.checked)}
                                    style={{accentColor: 'var(--accent)'}}
                                />
                                <span style={{fontSize: '0.85rem'}}>Include Background</span>
                            </label>
                            {!exportWithAudio && (
                                <p style={{fontSize: '0.7rem', color: '#888', marginTop: 8}}>
                                    Video will be exported without sound.
                                </p>
                            )}
                            {!exportWithBackground && bgRemovalEnabled && (
                                <p style={{fontSize: '0.7rem', color: '#888', marginTop: 8}}>
                                    Character will be exported on transparent/black background.
                                </p>
                            )}
                        </div>

                        {!isAnimating ? (
                            <button className="btn btn-primary" style={{padding:15, fontSize:'1.1em'}} onClick={startAnimation} disabled={polyPoints.length < 3}>Animate & Record</button>
                        ) : (
                            <button className="btn btn-danger" style={{padding:15, fontSize:'1.1em'}} onClick={stopEverything}>Stop</button>
                        )}

                        <div style={{textAlign:'center', color:'#666', fontSize:'0.8rem'}}>{status}</div>

                        {recordedVideo && (
                            <div className="panel" style={{textAlign:'center', borderColor:'#00ff99'}}>
                                <h3 style={{color:'#00ff99', margin:0}}>Result Ready</h3>
                                <video controls src={recordedVideo} style={{width:'100%', marginTop:10, borderRadius:4}} />
                                <a href={recordedVideo} download="lipsync_3d.webm" className="btn btn-primary" style={{display:'block', marginTop:10, textDecoration:'none'}}>Download</a>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
